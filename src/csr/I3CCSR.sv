// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module I3CCSR (
        input wire clk,
        input wire rst,

        input wire s_cpuif_req,
        input wire s_cpuif_req_is_wr,
        input wire [11:0] s_cpuif_addr,
        input wire [31:0] s_cpuif_wr_data,
        input wire [31:0] s_cpuif_wr_biten,
        output wire s_cpuif_req_stall_wr,
        output wire s_cpuif_req_stall_rd,
        output wire s_cpuif_rd_ack,
        output wire s_cpuif_rd_err,
        output wire [31:0] s_cpuif_rd_data,
        output wire s_cpuif_wr_ack,
        output wire s_cpuif_wr_err,

        input I3CCSR_pkg::I3CCSR__in_t hwif_in,
        output I3CCSR_pkg::I3CCSR__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [11:0] cpuif_addr;
    logic [31:0] cpuif_wr_data;
    logic [31:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [31:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    assign cpuif_req = s_cpuif_req;
    assign cpuif_req_is_wr = s_cpuif_req_is_wr;
    assign cpuif_addr = s_cpuif_addr;
    assign cpuif_wr_data = s_cpuif_wr_data;
    assign cpuif_wr_biten = s_cpuif_wr_biten;
    assign s_cpuif_req_stall_wr = cpuif_req_stall_wr;
    assign s_cpuif_req_stall_rd = cpuif_req_stall_rd;
    assign s_cpuif_rd_ack = cpuif_rd_ack;
    assign s_cpuif_rd_err = cpuif_rd_err;
    assign s_cpuif_rd_data = cpuif_rd_data;
    assign s_cpuif_wr_ack = cpuif_wr_ack;
    assign s_cpuif_wr_err = cpuif_wr_err;

    logic cpuif_req_masked;
    logic external_req;
    logic external_pending;
    logic external_wr_ack;
    logic external_rd_ack;
    always_ff @(posedge clk) begin
        if(rst) begin
            external_pending <= '0;
        end else begin
            if(external_req & ~external_wr_ack & ~external_rd_ack) external_pending <= '1;
            else if(external_wr_ack | external_rd_ack) external_pending <= '0;
            assert(!external_wr_ack || (external_pending | external_req))
                else $error("An external wr_ack strobe was asserted when no external request was active");
            assert(!external_rd_ack || (external_pending | external_req))
                else $error("An external rd_ack strobe was asserted when no external request was active");
        end
    end

    // Read & write latencies are balanced. Stalls not required
    // except if external
    assign cpuif_req_stall_rd = external_pending;
    assign cpuif_req_stall_wr = external_pending;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            logic HCI_VERSION;
            logic HC_CONTROL;
            logic CONTROLLER_DEVICE_ADDR;
            logic HC_CAPABILITIES;
            logic RESET_CONTROL;
            logic PRESENT_STATE;
            logic INTR_STATUS;
            logic INTR_STATUS_ENABLE;
            logic INTR_SIGNAL_ENABLE;
            logic INTR_FORCE;
            logic DAT_SECTION_OFFSET;
            logic DCT_SECTION_OFFSET;
            logic RING_HEADERS_SECTION_OFFSET;
            logic PIO_SECTION_OFFSET;
            logic EXT_CAPS_SECTION_OFFSET;
            logic INT_CTRL_CMDS_EN;
            logic IBI_NOTIFY_CTRL;
            logic IBI_DATA_ABORT_CTRL;
            logic DEV_CTX_BASE_LO;
            logic DEV_CTX_BASE_HI;
            logic DEV_CTX_SG;
        } I3CBase;
        struct {
            logic COMMAND_PORT;
            logic RESPONSE_PORT;
            logic XFER_DATA_PORT;
            logic IBI_PORT;
            logic QUEUE_THLD_CTRL;
            logic DATA_BUFFER_THLD_CTRL;
            logic QUEUE_SIZE;
            logic ALT_QUEUE_SIZE;
            logic PIO_INTR_STATUS;
            logic PIO_INTR_STATUS_ENABLE;
            logic PIO_INTR_SIGNAL_ENABLE;
            logic PIO_INTR_FORCE;
            logic PIO_CONTROL;
        } PIOControl;
        logic DAT;
        logic DCT;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_strb_is_external;

    logic [11:0] decoded_addr;

    logic decoded_req;
    logic decoded_req_is_wr;
    logic [31:0] decoded_wr_data;
    logic [31:0] decoded_wr_biten;

    always_comb begin
        automatic logic is_external;
        is_external = '0;
        decoded_reg_strb.I3CBase.HCI_VERSION = cpuif_req_masked & (cpuif_addr == 12'h0);
        decoded_reg_strb.I3CBase.HC_CONTROL = cpuif_req_masked & (cpuif_addr == 12'h4);
        decoded_reg_strb.I3CBase.CONTROLLER_DEVICE_ADDR = cpuif_req_masked & (cpuif_addr == 12'h8);
        decoded_reg_strb.I3CBase.HC_CAPABILITIES = cpuif_req_masked & (cpuif_addr == 12'hc);
        decoded_reg_strb.I3CBase.RESET_CONTROL = cpuif_req_masked & (cpuif_addr == 12'h10);
        decoded_reg_strb.I3CBase.PRESENT_STATE = cpuif_req_masked & (cpuif_addr == 12'h14);
        decoded_reg_strb.I3CBase.INTR_STATUS = cpuif_req_masked & (cpuif_addr == 12'h20);
        decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE = cpuif_req_masked & (cpuif_addr == 12'h24);
        decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE = cpuif_req_masked & (cpuif_addr == 12'h28);
        decoded_reg_strb.I3CBase.INTR_FORCE = cpuif_req_masked & (cpuif_addr == 12'h2c);
        decoded_reg_strb.I3CBase.DAT_SECTION_OFFSET = cpuif_req_masked & (cpuif_addr == 12'h30);
        decoded_reg_strb.I3CBase.DCT_SECTION_OFFSET = cpuif_req_masked & (cpuif_addr == 12'h34);
        decoded_reg_strb.I3CBase.RING_HEADERS_SECTION_OFFSET = cpuif_req_masked & (cpuif_addr == 12'h38);
        decoded_reg_strb.I3CBase.PIO_SECTION_OFFSET = cpuif_req_masked & (cpuif_addr == 12'h3c);
        decoded_reg_strb.I3CBase.EXT_CAPS_SECTION_OFFSET = cpuif_req_masked & (cpuif_addr == 12'h40);
        decoded_reg_strb.I3CBase.INT_CTRL_CMDS_EN = cpuif_req_masked & (cpuif_addr == 12'h4c);
        decoded_reg_strb.I3CBase.IBI_NOTIFY_CTRL = cpuif_req_masked & (cpuif_addr == 12'h58);
        decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL = cpuif_req_masked & (cpuif_addr == 12'h5c);
        decoded_reg_strb.I3CBase.DEV_CTX_BASE_LO = cpuif_req_masked & (cpuif_addr == 12'h60);
        decoded_reg_strb.I3CBase.DEV_CTX_BASE_HI = cpuif_req_masked & (cpuif_addr == 12'h64);
        decoded_reg_strb.I3CBase.DEV_CTX_SG = cpuif_req_masked & (cpuif_addr == 12'h68);
        decoded_reg_strb.PIOControl.COMMAND_PORT = cpuif_req_masked & (cpuif_addr == 12'h100);
        is_external |= cpuif_req_masked & (cpuif_addr == 12'h100) & cpuif_req_is_wr;
        decoded_reg_strb.PIOControl.RESPONSE_PORT = cpuif_req_masked & (cpuif_addr == 12'h104);
        is_external |= cpuif_req_masked & (cpuif_addr == 12'h104) & !cpuif_req_is_wr;
        decoded_reg_strb.PIOControl.XFER_DATA_PORT = cpuif_req_masked & (cpuif_addr == 12'h108);
        is_external |= cpuif_req_masked & (cpuif_addr == 12'h108);
        decoded_reg_strb.PIOControl.IBI_PORT = cpuif_req_masked & (cpuif_addr == 12'h10c);
        is_external |= cpuif_req_masked & (cpuif_addr == 12'h10c) & !cpuif_req_is_wr;
        decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL = cpuif_req_masked & (cpuif_addr == 12'h110);
        decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL = cpuif_req_masked & (cpuif_addr == 12'h114);
        decoded_reg_strb.PIOControl.QUEUE_SIZE = cpuif_req_masked & (cpuif_addr == 12'h118);
        decoded_reg_strb.PIOControl.ALT_QUEUE_SIZE = cpuif_req_masked & (cpuif_addr == 12'h11c);
        decoded_reg_strb.PIOControl.PIO_INTR_STATUS = cpuif_req_masked & (cpuif_addr == 12'h120);
        decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE = cpuif_req_masked & (cpuif_addr == 12'h124);
        decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE = cpuif_req_masked & (cpuif_addr == 12'h128);
        decoded_reg_strb.PIOControl.PIO_INTR_FORCE = cpuif_req_masked & (cpuif_addr == 12'h12c);
        decoded_reg_strb.PIOControl.PIO_CONTROL = cpuif_req_masked & (cpuif_addr == 12'h130);
        decoded_reg_strb.DAT = cpuif_req_masked & (cpuif_addr >= 12'h400) & (cpuif_addr <= 12'h400 + 12'h3ff);
        is_external |= cpuif_req_masked & (cpuif_addr >= 12'h400) & (cpuif_addr <= 12'h400 + 12'h3ff);
        decoded_reg_strb.DCT = cpuif_req_masked & (cpuif_addr >= 12'h800) & (cpuif_addr <= 12'h800 + 12'h7ff);
        is_external |= cpuif_req_masked & (cpuif_addr >= 12'h800) & (cpuif_addr <= 12'h800 + 12'h7ff);
        decoded_strb_is_external = is_external;
        external_req = is_external;
    end

    // Pass down signals to next stage
    assign decoded_addr = cpuif_addr;

    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                struct {
                    logic next;
                    logic load_next;
                } IBA_INCLUDE;
                struct {
                    logic next;
                    logic load_next;
                } I2C_DEV_PRESENT;
                struct {
                    logic next;
                    logic load_next;
                } HOT_JOIN_CTRL;
                struct {
                    logic next;
                    logic load_next;
                } HALT_ON_CMD_SEQ_TIMEOUT;
                struct {
                    logic next;
                    logic load_next;
                } ABORT;
                struct {
                    logic next;
                    logic load_next;
                } RESUME;
                struct {
                    logic next;
                    logic load_next;
                } BUS_ENABLE;
            } HC_CONTROL;
            struct {
                struct {
                    logic [6:0] next;
                    logic load_next;
                } DYNAMIC_ADDR;
                struct {
                    logic next;
                    logic load_next;
                } DYNAMIC_ADDR_VALID;
            } CONTROLLER_DEVICE_ADDR;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } SOFT_RST;
                struct {
                    logic next;
                    logic load_next;
                } CMD_QUEUE_RST;
                struct {
                    logic next;
                    logic load_next;
                } RESP_QUEUE_RST;
                struct {
                    logic next;
                    logic load_next;
                } TX_FIFO_RST;
                struct {
                    logic next;
                    logic load_next;
                } RX_FIFO_RST;
                struct {
                    logic next;
                    logic load_next;
                } IBI_QUEUE_RST;
            } RESET_CONTROL;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } HC_INTERNAL_ERR_STAT;
                struct {
                    logic next;
                    logic load_next;
                } HC_SEQ_CANCEL_STAT;
                struct {
                    logic next;
                    logic load_next;
                } HC_WARN_CMD_SEQ_STALL_STAT;
                struct {
                    logic next;
                    logic load_next;
                } HC_ERR_CMD_SEQ_TIMEOUT_STAT;
                struct {
                    logic next;
                    logic load_next;
                } SCHED_CMD_MISSED_TICK_STAT;
            } INTR_STATUS;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } HC_INTERNAL_ERR_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } HC_SEQ_CANCEL_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } HC_WARN_CMD_SEQ_STALL_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } SCHED_CMD_MISSED_TICK_STAT_EN;
            } INTR_STATUS_ENABLE;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } HC_INTERNAL_ERR_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } HC_SEQ_CANCEL_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } HC_WARN_CMD_SEQ_STALL_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } SCHED_CMD_MISSED_TICK_SIGNAL_EN;
            } INTR_SIGNAL_ENABLE;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } HC_INTERNAL_ERR_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } HC_SEQ_CANCEL_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } HC_WARN_CMD_SEQ_STALL_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } HC_ERR_CMD_SEQ_TIMEOUT_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } SCHED_CMD_MISSED_TICK_FORCE;
            } INTR_FORCE;
            struct {
                struct {
                    logic [4:0] next;
                    logic load_next;
                } TABLE_INDEX;
            } DCT_SECTION_OFFSET;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } NOTIFY_HJ_REJECTED;
                struct {
                    logic next;
                    logic load_next;
                } NOTIFY_CRR_REJECTED;
                struct {
                    logic next;
                    logic load_next;
                } NOTIFY_IBI_REJECTED;
            } IBI_NOTIFY_CTRL;
            struct {
                struct {
                    logic [7:0] next;
                    logic load_next;
                } MATCH_IBI_ID;
                struct {
                    logic [1:0] next;
                    logic load_next;
                } AFTER_N_CHUNKS;
                struct {
                    logic [2:0] next;
                    logic load_next;
                } MATCH_STATUS_TYPE;
                struct {
                    logic next;
                    logic load_next;
                } IBI_DATA_ABORT_MON;
            } IBI_DATA_ABORT_CTRL;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } BASE_LO;
            } DEV_CTX_BASE_LO;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } BASE_HI;
            } DEV_CTX_BASE_HI;
        } I3CBase;
        struct {
            struct {
                struct {
                    logic [7:0] next;
                    logic load_next;
                } CMD_EMPTY_BUF_THLD;
                struct {
                    logic [7:0] next;
                    logic load_next;
                } RESP_BUF_THLD;
                struct {
                    logic [7:0] next;
                    logic load_next;
                } IBI_DATA_SEGMENT_SIZE;
                struct {
                    logic [7:0] next;
                    logic load_next;
                } IBI_STATUS_THLD;
            } QUEUE_THLD_CTRL;
            struct {
                struct {
                    logic [2:0] next;
                    logic load_next;
                } TX_BUF_THLD;
                struct {
                    logic [2:0] next;
                    logic load_next;
                } RX_BUF_THLD;
                struct {
                    logic [2:0] next;
                    logic load_next;
                } TX_START_THLD;
                struct {
                    logic [2:0] next;
                    logic load_next;
                } RX_START_THLD;
            } DATA_BUFFER_THLD_CTRL;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } TX_THLD_STAT;
                struct {
                    logic next;
                    logic load_next;
                } RX_THLD_STAT;
                struct {
                    logic next;
                    logic load_next;
                } IBI_STATUS_THLD_STAT;
                struct {
                    logic next;
                    logic load_next;
                } CMD_QUEUE_READY_STAT;
                struct {
                    logic next;
                    logic load_next;
                } RESP_READY_STAT;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ABORT_STAT;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ERR_STAT;
            } PIO_INTR_STATUS;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } TX_THLD_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } RX_THLD_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } IBI_STATUS_THLD_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } CMD_QUEUE_READY_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } RESP_READY_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ABORT_STAT_EN;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ERR_STAT_EN;
            } PIO_INTR_STATUS_ENABLE;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } TX_THLD_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } RX_THLD_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } IBI_STATUS_THLD_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } CMD_QUEUE_READY_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } RESP_READY_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ABORT_SIGNAL_EN;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ERR_SIGNAL_EN;
            } PIO_INTR_SIGNAL_ENABLE;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } TX_THLD_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } RX_THLD_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } IBI_THLD_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } CMD_QUEUE_READY_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } RESP_READY_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ABORT_FORCE;
                struct {
                    logic next;
                    logic load_next;
                } TRANSFER_ERR_FORCE;
            } PIO_INTR_FORCE;
            struct {
                struct {
                    logic next;
                    logic load_next;
                } ENABLE;
                struct {
                    logic next;
                    logic load_next;
                } RS;
                struct {
                    logic next;
                    logic load_next;
                } ABORT;
            } PIO_CONTROL;
        } PIOControl;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                struct {
                    logic value;
                } IBA_INCLUDE;
                struct {
                    logic value;
                } I2C_DEV_PRESENT;
                struct {
                    logic value;
                } HOT_JOIN_CTRL;
                struct {
                    logic value;
                } HALT_ON_CMD_SEQ_TIMEOUT;
                struct {
                    logic value;
                } ABORT;
                struct {
                    logic value;
                } RESUME;
                struct {
                    logic value;
                } BUS_ENABLE;
            } HC_CONTROL;
            struct {
                struct {
                    logic [6:0] value;
                } DYNAMIC_ADDR;
                struct {
                    logic value;
                } DYNAMIC_ADDR_VALID;
            } CONTROLLER_DEVICE_ADDR;
            struct {
                struct {
                    logic value;
                } SOFT_RST;
                struct {
                    logic value;
                } CMD_QUEUE_RST;
                struct {
                    logic value;
                } RESP_QUEUE_RST;
                struct {
                    logic value;
                } TX_FIFO_RST;
                struct {
                    logic value;
                } RX_FIFO_RST;
                struct {
                    logic value;
                } IBI_QUEUE_RST;
            } RESET_CONTROL;
            struct {
                struct {
                    logic value;
                } HC_INTERNAL_ERR_STAT;
                struct {
                    logic value;
                } HC_SEQ_CANCEL_STAT;
                struct {
                    logic value;
                } HC_WARN_CMD_SEQ_STALL_STAT;
                struct {
                    logic value;
                } HC_ERR_CMD_SEQ_TIMEOUT_STAT;
                struct {
                    logic value;
                } SCHED_CMD_MISSED_TICK_STAT;
            } INTR_STATUS;
            struct {
                struct {
                    logic value;
                } HC_INTERNAL_ERR_STAT_EN;
                struct {
                    logic value;
                } HC_SEQ_CANCEL_STAT_EN;
                struct {
                    logic value;
                } HC_WARN_CMD_SEQ_STALL_STAT_EN;
                struct {
                    logic value;
                } HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN;
                struct {
                    logic value;
                } SCHED_CMD_MISSED_TICK_STAT_EN;
            } INTR_STATUS_ENABLE;
            struct {
                struct {
                    logic value;
                } HC_INTERNAL_ERR_SIGNAL_EN;
                struct {
                    logic value;
                } HC_SEQ_CANCEL_SIGNAL_EN;
                struct {
                    logic value;
                } HC_WARN_CMD_SEQ_STALL_SIGNAL_EN;
                struct {
                    logic value;
                } HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN;
                struct {
                    logic value;
                } SCHED_CMD_MISSED_TICK_SIGNAL_EN;
            } INTR_SIGNAL_ENABLE;
            struct {
                struct {
                    logic value;
                } HC_INTERNAL_ERR_FORCE;
                struct {
                    logic value;
                } HC_SEQ_CANCEL_FORCE;
                struct {
                    logic value;
                } HC_WARN_CMD_SEQ_STALL_FORCE;
                struct {
                    logic value;
                } HC_ERR_CMD_SEQ_TIMEOUT_FORCE;
                struct {
                    logic value;
                } SCHED_CMD_MISSED_TICK_FORCE;
            } INTR_FORCE;
            struct {
                struct {
                    logic [4:0] value;
                } TABLE_INDEX;
            } DCT_SECTION_OFFSET;
            struct {
                struct {
                    logic value;
                } NOTIFY_HJ_REJECTED;
                struct {
                    logic value;
                } NOTIFY_CRR_REJECTED;
                struct {
                    logic value;
                } NOTIFY_IBI_REJECTED;
            } IBI_NOTIFY_CTRL;
            struct {
                struct {
                    logic [7:0] value;
                } MATCH_IBI_ID;
                struct {
                    logic [1:0] value;
                } AFTER_N_CHUNKS;
                struct {
                    logic [2:0] value;
                } MATCH_STATUS_TYPE;
                struct {
                    logic value;
                } IBI_DATA_ABORT_MON;
            } IBI_DATA_ABORT_CTRL;
            struct {
                struct {
                    logic value;
                } BASE_LO;
            } DEV_CTX_BASE_LO;
            struct {
                struct {
                    logic value;
                } BASE_HI;
            } DEV_CTX_BASE_HI;
        } I3CBase;
        struct {
            struct {
                struct {
                    logic [7:0] value;
                } CMD_EMPTY_BUF_THLD;
                struct {
                    logic [7:0] value;
                } RESP_BUF_THLD;
                struct {
                    logic [7:0] value;
                } IBI_DATA_SEGMENT_SIZE;
                struct {
                    logic [7:0] value;
                } IBI_STATUS_THLD;
            } QUEUE_THLD_CTRL;
            struct {
                struct {
                    logic [2:0] value;
                } TX_BUF_THLD;
                struct {
                    logic [2:0] value;
                } RX_BUF_THLD;
                struct {
                    logic [2:0] value;
                } TX_START_THLD;
                struct {
                    logic [2:0] value;
                } RX_START_THLD;
            } DATA_BUFFER_THLD_CTRL;
            struct {
                struct {
                    logic value;
                } TX_THLD_STAT;
                struct {
                    logic value;
                } RX_THLD_STAT;
                struct {
                    logic value;
                } IBI_STATUS_THLD_STAT;
                struct {
                    logic value;
                } CMD_QUEUE_READY_STAT;
                struct {
                    logic value;
                } RESP_READY_STAT;
                struct {
                    logic value;
                } TRANSFER_ABORT_STAT;
                struct {
                    logic value;
                } TRANSFER_ERR_STAT;
            } PIO_INTR_STATUS;
            struct {
                struct {
                    logic value;
                } TX_THLD_STAT_EN;
                struct {
                    logic value;
                } RX_THLD_STAT_EN;
                struct {
                    logic value;
                } IBI_STATUS_THLD_STAT_EN;
                struct {
                    logic value;
                } CMD_QUEUE_READY_STAT_EN;
                struct {
                    logic value;
                } RESP_READY_STAT_EN;
                struct {
                    logic value;
                } TRANSFER_ABORT_STAT_EN;
                struct {
                    logic value;
                } TRANSFER_ERR_STAT_EN;
            } PIO_INTR_STATUS_ENABLE;
            struct {
                struct {
                    logic value;
                } TX_THLD_SIGNAL_EN;
                struct {
                    logic value;
                } RX_THLD_SIGNAL_EN;
                struct {
                    logic value;
                } IBI_STATUS_THLD_SIGNAL_EN;
                struct {
                    logic value;
                } CMD_QUEUE_READY_SIGNAL_EN;
                struct {
                    logic value;
                } RESP_READY_SIGNAL_EN;
                struct {
                    logic value;
                } TRANSFER_ABORT_SIGNAL_EN;
                struct {
                    logic value;
                } TRANSFER_ERR_SIGNAL_EN;
            } PIO_INTR_SIGNAL_ENABLE;
            struct {
                struct {
                    logic value;
                } TX_THLD_FORCE;
                struct {
                    logic value;
                } RX_THLD_FORCE;
                struct {
                    logic value;
                } IBI_THLD_FORCE;
                struct {
                    logic value;
                } CMD_QUEUE_READY_FORCE;
                struct {
                    logic value;
                } RESP_READY_FORCE;
                struct {
                    logic value;
                } TRANSFER_ABORT_FORCE;
                struct {
                    logic value;
                } TRANSFER_ERR_FORCE;
            } PIO_INTR_FORCE;
            struct {
                struct {
                    logic value;
                } ENABLE;
                struct {
                    logic value;
                } RS;
                struct {
                    logic value;
                } ABORT;
            } PIO_CONTROL;
        } PIOControl;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: I3CCSR.I3CBase.HC_CONTROL.IBA_INCLUDE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.HC_CONTROL.IBA_INCLUDE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.HC_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.HC_CONTROL.IBA_INCLUDE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.I3CBase.HC_CONTROL.IBA_INCLUDE.next = next_c;
        field_combo.I3CBase.HC_CONTROL.IBA_INCLUDE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.HC_CONTROL.IBA_INCLUDE.value <= 1'h0;
        end else if(field_combo.I3CBase.HC_CONTROL.IBA_INCLUDE.load_next) begin
            field_storage.I3CBase.HC_CONTROL.IBA_INCLUDE.value <= field_combo.I3CBase.HC_CONTROL.IBA_INCLUDE.next;
        end
    end
    assign hwif_out.I3CBase.HC_CONTROL.IBA_INCLUDE.value = field_storage.I3CBase.HC_CONTROL.IBA_INCLUDE.value;
    // Field: I3CCSR.I3CBase.HC_CONTROL.I2C_DEV_PRESENT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.HC_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end
        field_combo.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.next = next_c;
        field_combo.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.value <= 1'h0;
        end else if(field_combo.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.load_next) begin
            field_storage.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.value <= field_combo.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.next;
        end
    end
    assign hwif_out.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.value = field_storage.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.value;
    // Field: I3CCSR.I3CBase.HC_CONTROL.HOT_JOIN_CTRL
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.HC_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.value & ~decoded_wr_biten[8:8]) | (decoded_wr_data[8:8] & decoded_wr_biten[8:8]);
            load_next_c = '1;
        end
        field_combo.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.next = next_c;
        field_combo.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.value <= 1'h0;
        end else if(field_combo.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.load_next) begin
            field_storage.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.value <= field_combo.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.next;
        end
    end
    assign hwif_out.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.value = field_storage.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.value;
    // Field: I3CCSR.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.HC_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end
        field_combo.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.next = next_c;
        field_combo.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.value <= 1'h0;
        end else if(field_combo.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.load_next) begin
            field_storage.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.value <= field_combo.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.next;
        end
    end
    assign hwif_out.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.value = field_storage.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.value;
    // Field: I3CCSR.I3CBase.HC_CONTROL.ABORT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.HC_CONTROL.ABORT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.HC_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.HC_CONTROL.ABORT.value & ~decoded_wr_biten[29:29]) | (decoded_wr_data[29:29] & decoded_wr_biten[29:29]);
            load_next_c = '1;
        end
        field_combo.I3CBase.HC_CONTROL.ABORT.next = next_c;
        field_combo.I3CBase.HC_CONTROL.ABORT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.HC_CONTROL.ABORT.value <= 1'h0;
        end else if(field_combo.I3CBase.HC_CONTROL.ABORT.load_next) begin
            field_storage.I3CBase.HC_CONTROL.ABORT.value <= field_combo.I3CBase.HC_CONTROL.ABORT.next;
        end
    end
    assign hwif_out.I3CBase.HC_CONTROL.ABORT.value = field_storage.I3CBase.HC_CONTROL.ABORT.value;
    // Field: I3CCSR.I3CBase.HC_CONTROL.RESUME
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.HC_CONTROL.RESUME.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.HC_CONTROL && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.I3CBase.HC_CONTROL.RESUME.value & ~(decoded_wr_data[30:30] & decoded_wr_biten[30:30]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.HC_CONTROL.RESUME.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.HC_CONTROL.RESUME.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.HC_CONTROL.RESUME.next = next_c;
        field_combo.I3CBase.HC_CONTROL.RESUME.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.HC_CONTROL.RESUME.value <= 1'h0;
        end else if(field_combo.I3CBase.HC_CONTROL.RESUME.load_next) begin
            field_storage.I3CBase.HC_CONTROL.RESUME.value <= field_combo.I3CBase.HC_CONTROL.RESUME.next;
        end
    end
    assign hwif_out.I3CBase.HC_CONTROL.RESUME.value = field_storage.I3CBase.HC_CONTROL.RESUME.value;
    // Field: I3CCSR.I3CBase.HC_CONTROL.BUS_ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.HC_CONTROL.BUS_ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.HC_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.HC_CONTROL.BUS_ENABLE.value & ~decoded_wr_biten[31:31]) | (decoded_wr_data[31:31] & decoded_wr_biten[31:31]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.HC_CONTROL.BUS_ENABLE.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.HC_CONTROL.BUS_ENABLE.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.HC_CONTROL.BUS_ENABLE.next = next_c;
        field_combo.I3CBase.HC_CONTROL.BUS_ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.HC_CONTROL.BUS_ENABLE.value <= 1'h0;
        end else if(field_combo.I3CBase.HC_CONTROL.BUS_ENABLE.load_next) begin
            field_storage.I3CBase.HC_CONTROL.BUS_ENABLE.value <= field_combo.I3CBase.HC_CONTROL.BUS_ENABLE.next;
        end
    end
    assign hwif_out.I3CBase.HC_CONTROL.BUS_ENABLE.value = field_storage.I3CBase.HC_CONTROL.BUS_ENABLE.value;
    // Field: I3CCSR.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR
    always_comb begin
        automatic logic [6:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.CONTROLLER_DEVICE_ADDR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.value & ~decoded_wr_biten[22:16]) | (decoded_wr_data[22:16] & decoded_wr_biten[22:16]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.next = next_c;
        field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.value <= 7'h0;
        end else if(field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.load_next) begin
            field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.value <= field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.next;
        end
    end
    assign hwif_out.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.value = field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.value;
    // Field: I3CCSR.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.CONTROLLER_DEVICE_ADDR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.value & ~decoded_wr_biten[31:31]) | (decoded_wr_data[31:31] & decoded_wr_biten[31:31]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.next = next_c;
        field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.value <= 1'h0;
        end else if(field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.load_next) begin
            field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.value <= field_combo.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.next;
        end
    end
    assign hwif_out.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.value = field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.value;
    // Field: I3CCSR.I3CBase.RESET_CONTROL.SOFT_RST
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.RESET_CONTROL.SOFT_RST.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.RESET_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.RESET_CONTROL.SOFT_RST.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.RESET_CONTROL.SOFT_RST.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.RESET_CONTROL.SOFT_RST.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.RESET_CONTROL.SOFT_RST.next = next_c;
        field_combo.I3CBase.RESET_CONTROL.SOFT_RST.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.RESET_CONTROL.SOFT_RST.value <= 1'h0;
        end else if(field_combo.I3CBase.RESET_CONTROL.SOFT_RST.load_next) begin
            field_storage.I3CBase.RESET_CONTROL.SOFT_RST.value <= field_combo.I3CBase.RESET_CONTROL.SOFT_RST.next;
        end
    end
    assign hwif_out.I3CBase.RESET_CONTROL.SOFT_RST.value = field_storage.I3CBase.RESET_CONTROL.SOFT_RST.value;
    // Field: I3CCSR.I3CBase.RESET_CONTROL.CMD_QUEUE_RST
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.RESET_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.next = next_c;
        field_combo.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.value <= 1'h0;
        end else if(field_combo.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.load_next) begin
            field_storage.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.value <= field_combo.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.next;
        end
    end
    assign hwif_out.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.value = field_storage.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.value;
    // Field: I3CCSR.I3CBase.RESET_CONTROL.RESP_QUEUE_RST
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.RESET_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.next = next_c;
        field_combo.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.value <= 1'h0;
        end else if(field_combo.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.load_next) begin
            field_storage.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.value <= field_combo.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.next;
        end
    end
    assign hwif_out.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.value = field_storage.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.value;
    // Field: I3CCSR.I3CBase.RESET_CONTROL.TX_FIFO_RST
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.RESET_CONTROL.TX_FIFO_RST.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.RESET_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.RESET_CONTROL.TX_FIFO_RST.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.RESET_CONTROL.TX_FIFO_RST.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.RESET_CONTROL.TX_FIFO_RST.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.RESET_CONTROL.TX_FIFO_RST.next = next_c;
        field_combo.I3CBase.RESET_CONTROL.TX_FIFO_RST.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.RESET_CONTROL.TX_FIFO_RST.value <= 1'h0;
        end else if(field_combo.I3CBase.RESET_CONTROL.TX_FIFO_RST.load_next) begin
            field_storage.I3CBase.RESET_CONTROL.TX_FIFO_RST.value <= field_combo.I3CBase.RESET_CONTROL.TX_FIFO_RST.next;
        end
    end
    assign hwif_out.I3CBase.RESET_CONTROL.TX_FIFO_RST.value = field_storage.I3CBase.RESET_CONTROL.TX_FIFO_RST.value;
    // Field: I3CCSR.I3CBase.RESET_CONTROL.RX_FIFO_RST
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.RESET_CONTROL.RX_FIFO_RST.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.RESET_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.RESET_CONTROL.RX_FIFO_RST.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.RESET_CONTROL.RX_FIFO_RST.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.RESET_CONTROL.RX_FIFO_RST.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.RESET_CONTROL.RX_FIFO_RST.next = next_c;
        field_combo.I3CBase.RESET_CONTROL.RX_FIFO_RST.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.RESET_CONTROL.RX_FIFO_RST.value <= 1'h0;
        end else if(field_combo.I3CBase.RESET_CONTROL.RX_FIFO_RST.load_next) begin
            field_storage.I3CBase.RESET_CONTROL.RX_FIFO_RST.value <= field_combo.I3CBase.RESET_CONTROL.RX_FIFO_RST.next;
        end
    end
    assign hwif_out.I3CBase.RESET_CONTROL.RX_FIFO_RST.value = field_storage.I3CBase.RESET_CONTROL.RX_FIFO_RST.value;
    // Field: I3CCSR.I3CBase.RESET_CONTROL.IBI_QUEUE_RST
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.RESET_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.value & ~decoded_wr_biten[5:5]) | (decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.next = next_c;
        field_combo.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.value <= 1'h0;
        end else if(field_combo.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.load_next) begin
            field_storage.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.value <= field_combo.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.next;
        end
    end
    assign hwif_out.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.value = field_storage.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.value;
    // Field: I3CCSR.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.value & ~(decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.next != '0) begin // stickybit
            next_c = field_storage.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.value | hwif_in.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.next = next_c;
        field_combo.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.load_next) begin
            field_storage.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.value <= field_combo.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.next;
        end
    end
    // Field: I3CCSR.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.value & ~(decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.next != '0) begin // stickybit
            next_c = field_storage.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.value | hwif_in.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.next = next_c;
        field_combo.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.load_next) begin
            field_storage.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.value <= field_combo.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.next;
        end
    end
    // Field: I3CCSR.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.value & ~(decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.next != '0) begin // stickybit
            next_c = field_storage.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.value | hwif_in.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.next = next_c;
        field_combo.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.load_next) begin
            field_storage.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.value <= field_combo.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.next;
        end
    end
    // Field: I3CCSR.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.value & ~(decoded_wr_data[13:13] & decoded_wr_biten[13:13]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.next != '0) begin // stickybit
            next_c = field_storage.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.value | hwif_in.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.next = next_c;
        field_combo.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.load_next) begin
            field_storage.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.value <= field_combo.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.next;
        end
    end
    // Field: I3CCSR.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.value & ~(decoded_wr_data[14:14] & decoded_wr_biten[14:14]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.next != '0) begin // stickybit
            next_c = field_storage.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.value | hwif_in.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.next = next_c;
        field_combo.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.load_next) begin
            field_storage.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.value <= field_combo.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.next;
        end
    end
    assign hwif_out.I3CBase.INTR_STATUS.intr =
        |(field_storage.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.value & field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value)
        || |(field_storage.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.value & field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value)
        || |(field_storage.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.value & field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value)
        || |(field_storage.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.value & field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value)
        || |(field_storage.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.value & field_storage.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value);
    // Field: I3CCSR.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.next = next_c;
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.load_next) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.value <= field_combo.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.value = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.value;
    // Field: I3CCSR.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.next = next_c;
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.load_next) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.value <= field_combo.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.value = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.value;
    // Field: I3CCSR.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.next = next_c;
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.load_next) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.value <= field_combo.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.value = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.value;
    // Field: I3CCSR.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.value & ~decoded_wr_biten[13:13]) | (decoded_wr_data[13:13] & decoded_wr_biten[13:13]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.next = next_c;
        field_combo.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.load_next) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.value <= field_combo.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.value = field_storage.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.value;
    // Field: I3CCSR.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.value & ~decoded_wr_biten[14:14]) | (decoded_wr_data[14:14] & decoded_wr_biten[14:14]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.next = next_c;
        field_combo.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.load_next) begin
            field_storage.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.value <= field_combo.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.value = field_storage.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.value;
    // Field: I3CCSR.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.next = next_c;
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.load_next) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value <= field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value;
    // Field: I3CCSR.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.next = next_c;
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.load_next) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value <= field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value;
    // Field: I3CCSR.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.next = next_c;
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.load_next) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value <= field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value;
    // Field: I3CCSR.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value & ~decoded_wr_biten[13:13]) | (decoded_wr_data[13:13] & decoded_wr_biten[13:13]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.next = next_c;
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.load_next) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value <= field_combo.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value = field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value;
    // Field: I3CCSR.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value & ~decoded_wr_biten[14:14]) | (decoded_wr_data[14:14] & decoded_wr_biten[14:14]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.next = next_c;
        field_combo.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.load_next) begin
            field_storage.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value <= field_combo.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.next;
        end
    end
    assign hwif_out.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value = field_storage.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value;
    // Field: I3CCSR.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.next = next_c;
        field_combo.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.load_next) begin
            field_storage.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.value <= field_combo.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.next;
        end
    end
    assign hwif_out.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.value = field_storage.I3CBase.INTR_FORCE.HC_INTERNAL_ERR_FORCE.value;
    // Field: I3CCSR.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.next = next_c;
        field_combo.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.load_next) begin
            field_storage.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.value <= field_combo.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.next;
        end
    end
    assign hwif_out.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.value = field_storage.I3CBase.INTR_FORCE.HC_SEQ_CANCEL_FORCE.value;
    // Field: I3CCSR.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.next = next_c;
        field_combo.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.load_next) begin
            field_storage.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.value <= field_combo.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.next;
        end
    end
    assign hwif_out.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.value = field_storage.I3CBase.INTR_FORCE.HC_WARN_CMD_SEQ_STALL_FORCE.value;
    // Field: I3CCSR.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.value & ~decoded_wr_biten[13:13]) | (decoded_wr_data[13:13] & decoded_wr_biten[13:13]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.next = next_c;
        field_combo.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.load_next) begin
            field_storage.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.value <= field_combo.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.next;
        end
    end
    assign hwif_out.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.value = field_storage.I3CBase.INTR_FORCE.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.value;
    // Field: I3CCSR.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.value & ~decoded_wr_biten[14:14]) | (decoded_wr_data[14:14] & decoded_wr_biten[14:14]);
            load_next_c = '1;
        end
        field_combo.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.next = next_c;
        field_combo.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.value <= 1'h0;
        end else if(field_combo.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.load_next) begin
            field_storage.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.value <= field_combo.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.next;
        end
    end
    assign hwif_out.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.value = field_storage.I3CBase.INTR_FORCE.SCHED_CMD_MISSED_TICK_FORCE.value;
    // Field: I3CCSR.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.DCT_SECTION_OFFSET && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.value & ~decoded_wr_biten[23:19]) | (decoded_wr_data[23:19] & decoded_wr_biten[23:19]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.next = next_c;
        field_combo.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.value <= 5'h0;
        end else if(field_combo.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.load_next) begin
            field_storage.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.value <= field_combo.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.next;
        end
    end
    assign hwif_out.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.value = field_storage.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.value;
    // Field: I3CCSR.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.IBI_NOTIFY_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.next = next_c;
        field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.value <= 1'h0;
        end else if(field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.load_next) begin
            field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.value <= field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.next;
        end
    end
    assign hwif_out.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.value = field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.value;
    // Field: I3CCSR.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.IBI_NOTIFY_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.next = next_c;
        field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.value <= 1'h0;
        end else if(field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.load_next) begin
            field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.value <= field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.next;
        end
    end
    assign hwif_out.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.value = field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.value;
    // Field: I3CCSR.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.IBI_NOTIFY_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.next = next_c;
        field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.value <= 1'h0;
        end else if(field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.load_next) begin
            field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.value <= field_combo.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.next;
        end
    end
    assign hwif_out.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.value = field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.value;
    // Field: I3CCSR.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.next = next_c;
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.value <= 8'h0;
        end else if(field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.load_next) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.value <= field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.next;
        end
    end
    assign hwif_out.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.value = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.value;
    // Field: I3CCSR.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.value & ~decoded_wr_biten[17:16]) | (decoded_wr_data[17:16] & decoded_wr_biten[17:16]);
            load_next_c = '1;
        end
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.next = next_c;
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.value <= 2'h0;
        end else if(field_combo.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.load_next) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.value <= field_combo.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.next;
        end
    end
    assign hwif_out.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.value = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.value;
    // Field: I3CCSR.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.value & ~decoded_wr_biten[20:18]) | (decoded_wr_data[20:18] & decoded_wr_biten[20:18]);
            load_next_c = '1;
        end
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.next = next_c;
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.value <= 3'h0;
        end else if(field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.load_next) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.value <= field_combo.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.next;
        end
    end
    assign hwif_out.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.value = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.value;
    // Field: I3CCSR.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.value & ~decoded_wr_biten[31:31]) | (decoded_wr_data[31:31] & decoded_wr_biten[31:31]);
            load_next_c = '1;
        end else if(hwif_in.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.we) begin // HW Write - we
            next_c = hwif_in.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.next;
            load_next_c = '1;
        end
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.next = next_c;
        field_combo.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.value <= 1'h0;
        end else if(field_combo.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.load_next) begin
            field_storage.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.value <= field_combo.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.next;
        end
    end
    assign hwif_out.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.value = field_storage.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.value;
    // Field: I3CCSR.I3CBase.DEV_CTX_BASE_LO.BASE_LO
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.DEV_CTX_BASE_LO.BASE_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.DEV_CTX_BASE_LO && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.DEV_CTX_BASE_LO.BASE_LO.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.I3CBase.DEV_CTX_BASE_LO.BASE_LO.next = next_c;
        field_combo.I3CBase.DEV_CTX_BASE_LO.BASE_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.DEV_CTX_BASE_LO.BASE_LO.value <= 1'h0;
        end else if(field_combo.I3CBase.DEV_CTX_BASE_LO.BASE_LO.load_next) begin
            field_storage.I3CBase.DEV_CTX_BASE_LO.BASE_LO.value <= field_combo.I3CBase.DEV_CTX_BASE_LO.BASE_LO.next;
        end
    end
    assign hwif_out.I3CBase.DEV_CTX_BASE_LO.BASE_LO.value = field_storage.I3CBase.DEV_CTX_BASE_LO.BASE_LO.value;
    // Field: I3CCSR.I3CBase.DEV_CTX_BASE_HI.BASE_HI
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.I3CBase.DEV_CTX_BASE_HI.BASE_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.I3CBase.DEV_CTX_BASE_HI && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.I3CBase.DEV_CTX_BASE_HI.BASE_HI.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.I3CBase.DEV_CTX_BASE_HI.BASE_HI.next = next_c;
        field_combo.I3CBase.DEV_CTX_BASE_HI.BASE_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.I3CBase.DEV_CTX_BASE_HI.BASE_HI.value <= 1'h0;
        end else if(field_combo.I3CBase.DEV_CTX_BASE_HI.BASE_HI.load_next) begin
            field_storage.I3CBase.DEV_CTX_BASE_HI.BASE_HI.value <= field_combo.I3CBase.DEV_CTX_BASE_HI.BASE_HI.next;
        end
    end
    assign hwif_out.I3CBase.DEV_CTX_BASE_HI.BASE_HI.value = field_storage.I3CBase.DEV_CTX_BASE_HI.BASE_HI.value;

    assign hwif_out.PIOControl.COMMAND_PORT.req = decoded_req_is_wr ? decoded_reg_strb.PIOControl.COMMAND_PORT : '0;
    assign hwif_out.PIOControl.COMMAND_PORT.req_is_wr = decoded_req_is_wr;
    assign hwif_out.PIOControl.COMMAND_PORT.wr_data = decoded_wr_data;
    assign hwif_out.PIOControl.COMMAND_PORT.wr_biten = decoded_wr_biten;

    assign hwif_out.PIOControl.RESPONSE_PORT.req = !decoded_req_is_wr ? decoded_reg_strb.PIOControl.RESPONSE_PORT : '0;
    assign hwif_out.PIOControl.RESPONSE_PORT.req_is_wr = decoded_req_is_wr;

    assign hwif_out.PIOControl.XFER_DATA_PORT.req = decoded_reg_strb.PIOControl.XFER_DATA_PORT;
    assign hwif_out.PIOControl.XFER_DATA_PORT.req_is_wr = decoded_req_is_wr;
    assign hwif_out.PIOControl.XFER_DATA_PORT.wr_data = decoded_wr_data;
    assign hwif_out.PIOControl.XFER_DATA_PORT.wr_biten = decoded_wr_biten;

    assign hwif_out.PIOControl.IBI_PORT.req = !decoded_req_is_wr ? decoded_reg_strb.PIOControl.IBI_PORT : '0;
    assign hwif_out.PIOControl.IBI_PORT.req_is_wr = decoded_req_is_wr;
    // Field: I3CCSR.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.next = next_c;
        field_combo.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.value <= 8'h1;
        end else if(field_combo.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.load_next) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.value <= field_combo.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.next;
        end
    end
    assign hwif_out.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.value = field_storage.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.value;
    // Field: I3CCSR.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.next = next_c;
        field_combo.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.value <= 8'h1;
        end else if(field_combo.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.load_next) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.value <= field_combo.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.next;
        end
    end
    assign hwif_out.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.value = field_storage.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.value;
    // Field: I3CCSR.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.next = next_c;
        field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.value <= 8'h1;
        end else if(field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.load_next) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.value <= field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.next;
        end
    end
    assign hwif_out.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.value = field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.value;
    // Field: I3CCSR.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.next = next_c;
        field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.value <= 8'h1;
        end else if(field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.load_next) begin
            field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.value <= field_combo.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.next;
        end
    end
    assign hwif_out.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.value = field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.value;
    // Field: I3CCSR.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.value & ~decoded_wr_biten[2:0]) | (decoded_wr_data[2:0] & decoded_wr_biten[2:0]);
            load_next_c = '1;
        end
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.next = next_c;
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.value <= 3'h1;
        end else if(field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.load_next) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.value <= field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.next;
        end
    end
    assign hwif_out.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.value = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.value;
    // Field: I3CCSR.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.value & ~decoded_wr_biten[10:8]) | (decoded_wr_data[10:8] & decoded_wr_biten[10:8]);
            load_next_c = '1;
        end
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.next = next_c;
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.value <= 3'h1;
        end else if(field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.load_next) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.value <= field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.next;
        end
    end
    assign hwif_out.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.value = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.value;
    // Field: I3CCSR.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.value & ~decoded_wr_biten[18:16]) | (decoded_wr_data[18:16] & decoded_wr_biten[18:16]);
            load_next_c = '1;
        end
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.next = next_c;
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.value <= 3'h1;
        end else if(field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.load_next) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.value <= field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.next;
        end
    end
    assign hwif_out.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.value = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.value;
    // Field: I3CCSR.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.value & ~decoded_wr_biten[26:24]) | (decoded_wr_data[26:24] & decoded_wr_biten[26:24]);
            load_next_c = '1;
        end
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.next = next_c;
        field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.value <= 3'h1;
        end else if(field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.load_next) begin
            field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.value <= field_combo.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.next;
        end
    end
    assign hwif_out.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.value = field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.value;
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.value;
        load_next_c = '0;
        if(field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.value) begin // HW Write - we
            next_c = hwif_in.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.value <= field_combo.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.value;
        load_next_c = '0;
        if(field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.value) begin // HW Write - we
            next_c = hwif_in.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.value <= field_combo.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.value;
        load_next_c = '0;
        if(field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.value) begin // HW Write - we
            next_c = hwif_in.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.value <= field_combo.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.value;
        load_next_c = '0;
        if(field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.value) begin // HW Write - we
            next_c = hwif_in.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.value <= field_combo.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.value;
        load_next_c = '0;
        if(field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.value) begin // HW Write - we
            next_c = hwif_in.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.value <= field_combo.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.value & ~(decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
            load_next_c = '1;
        end else if(hwif_in.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.next != '0) begin // stickybit
            next_c = field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.value | hwif_in.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.value <= field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS && decoded_req_is_wr) begin // SW write 1 clear
            next_c = field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.value & ~(decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end else if(hwif_in.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.next != '0) begin // stickybit
            next_c = field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.value | hwif_in.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.value <= field_combo.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_STATUS.intr =
        |(field_storage.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.value & field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.value)
        || |(field_storage.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.value & field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.value)
        || |(field_storage.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.value & field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.value)
        || |(field_storage.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.value & field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.value)
        || |(field_storage.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.value & field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.value)
        || |(field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.value & field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.value)
        || |(field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.value & field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.value);
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.value <= field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.value <= field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.value <= field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.value <= field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.value <= field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.value & ~decoded_wr_biten[5:5]) | (decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.value <= field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.value & ~decoded_wr_biten[9:9]) | (decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.value <= field_combo.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.value <= field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.value <= field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.value <= field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.value <= field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.value <= field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.value & ~decoded_wr_biten[5:5]) | (decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.value <= field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.value & ~decoded_wr_biten[9:9]) | (decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.next = next_c;
        field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.load_next) begin
            field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.value <= field_combo.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.next = next_c;
        field_combo.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.load_next) begin
            field_storage.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.value <= field_combo.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.value = field_storage.PIOControl.PIO_INTR_FORCE.TX_THLD_FORCE.value;
    // Field: I3CCSR.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.next = next_c;
        field_combo.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.load_next) begin
            field_storage.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.value <= field_combo.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.value = field_storage.PIOControl.PIO_INTR_FORCE.RX_THLD_FORCE.value;
    // Field: I3CCSR.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.next = next_c;
        field_combo.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.load_next) begin
            field_storage.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.value <= field_combo.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.value = field_storage.PIOControl.PIO_INTR_FORCE.IBI_THLD_FORCE.value;
    // Field: I3CCSR.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.next = next_c;
        field_combo.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.load_next) begin
            field_storage.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.value <= field_combo.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.value = field_storage.PIOControl.PIO_INTR_FORCE.CMD_QUEUE_READY_FORCE.value;
    // Field: I3CCSR.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.next = next_c;
        field_combo.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.load_next) begin
            field_storage.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.value <= field_combo.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.value = field_storage.PIOControl.PIO_INTR_FORCE.RESP_READY_FORCE.value;
    // Field: I3CCSR.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.value & ~decoded_wr_biten[5:5]) | (decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.next = next_c;
        field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.load_next) begin
            field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.value <= field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.value = field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ABORT_FORCE.value;
    // Field: I3CCSR.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_INTR_FORCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.value & ~decoded_wr_biten[9:9]) | (decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.next = next_c;
        field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.load_next) begin
            field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.value <= field_combo.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.value = field_storage.PIOControl.PIO_INTR_FORCE.TRANSFER_ERR_FORCE.value;
    // Field: I3CCSR.PIOControl.PIO_CONTROL.ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_CONTROL.ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_CONTROL.ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_CONTROL.ENABLE.next = next_c;
        field_combo.PIOControl.PIO_CONTROL.ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_CONTROL.ENABLE.value <= 1'h1;
        end else if(field_combo.PIOControl.PIO_CONTROL.ENABLE.load_next) begin
            field_storage.PIOControl.PIO_CONTROL.ENABLE.value <= field_combo.PIOControl.PIO_CONTROL.ENABLE.next;
        end
    end
    assign hwif_out.PIOControl.PIO_CONTROL.ENABLE.value = field_storage.PIOControl.PIO_CONTROL.ENABLE.value;
    // Field: I3CCSR.PIOControl.PIO_CONTROL.RS
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_CONTROL.RS.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_CONTROL.RS.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else if(hwif_in.PIOControl.PIO_CONTROL.RS.we) begin // HW Write - we
            next_c = hwif_in.PIOControl.PIO_CONTROL.RS.next;
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_CONTROL.RS.next = next_c;
        field_combo.PIOControl.PIO_CONTROL.RS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_CONTROL.RS.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_CONTROL.RS.load_next) begin
            field_storage.PIOControl.PIO_CONTROL.RS.value <= field_combo.PIOControl.PIO_CONTROL.RS.next;
        end
    end
    // Field: I3CCSR.PIOControl.PIO_CONTROL.ABORT
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIOControl.PIO_CONTROL.ABORT.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIOControl.PIO_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIOControl.PIO_CONTROL.ABORT.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.PIOControl.PIO_CONTROL.ABORT.next = next_c;
        field_combo.PIOControl.PIO_CONTROL.ABORT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIOControl.PIO_CONTROL.ABORT.value <= 1'h0;
        end else if(field_combo.PIOControl.PIO_CONTROL.ABORT.load_next) begin
            field_storage.PIOControl.PIO_CONTROL.ABORT.value <= field_combo.PIOControl.PIO_CONTROL.ABORT.next;
        end
    end
    assign hwif_out.PIOControl.PIO_CONTROL.ABORT.value = field_storage.PIOControl.PIO_CONTROL.ABORT.value;
    assign hwif_out.DAT.req = decoded_reg_strb.DAT;
    assign hwif_out.DAT.addr = decoded_addr[10:0];
    assign hwif_out.DAT.req_is_wr = decoded_req_is_wr;
    assign hwif_out.DAT.wr_data = decoded_wr_data;
    assign hwif_out.DAT.wr_biten = decoded_wr_biten;
    assign hwif_out.DCT.req = decoded_reg_strb.DCT;
    assign hwif_out.DCT.addr = decoded_addr[11:0];
    assign hwif_out.DCT.req_is_wr = decoded_req_is_wr;
    assign hwif_out.DCT.wr_data = decoded_wr_data;
    assign hwif_out.DCT.wr_biten = decoded_wr_biten;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    always_comb begin
        automatic logic wr_ack;
        wr_ack = '0;
        wr_ack |= hwif_in.PIOControl.COMMAND_PORT.wr_ack;
        wr_ack |= hwif_in.PIOControl.XFER_DATA_PORT.wr_ack;
        wr_ack |= hwif_in.DAT.wr_ack;
        wr_ack |= hwif_in.DCT.wr_ack;
        external_wr_ack = wr_ack;
    end
    assign cpuif_wr_ack = external_wr_ack | (decoded_req & decoded_req_is_wr & ~decoded_strb_is_external);
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------
    logic readback_external_rd_ack_c;
    always_comb begin
        automatic logic rd_ack;
        rd_ack = '0;
        rd_ack |= hwif_in.PIOControl.RESPONSE_PORT.rd_ack;
        rd_ack |= hwif_in.PIOControl.XFER_DATA_PORT.rd_ack;
        rd_ack |= hwif_in.PIOControl.IBI_PORT.rd_ack;
        rd_ack |= hwif_in.DAT.rd_ack;
        rd_ack |= hwif_in.DCT.rd_ack;
        readback_external_rd_ack_c = rd_ack;
    end

    logic readback_external_rd_ack;

    assign readback_external_rd_ack = readback_external_rd_ack_c;

    logic readback_err;
    logic readback_done;
    logic [31:0] readback_data;

    // Assign readback values to a flattened array
    logic [31:0] readback_array[33];
    assign readback_array[0][31:0] = (decoded_reg_strb.I3CBase.HCI_VERSION && !decoded_req_is_wr) ? 32'h120 : '0;
    assign readback_array[1][0:0] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.HC_CONTROL.IBA_INCLUDE.value : '0;
    assign readback_array[1][2:1] = '0;
    assign readback_array[1][3:3] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[1][4:4] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[1][5:5] = '0;
    assign readback_array[1][6:6] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? 1'h1 : '0;
    assign readback_array[1][7:7] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.HC_CONTROL.I2C_DEV_PRESENT.value : '0;
    assign readback_array[1][8:8] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.HC_CONTROL.HOT_JOIN_CTRL.value : '0;
    assign readback_array[1][11:9] = '0;
    assign readback_array[1][12:12] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.HC_CONTROL.HALT_ON_CMD_SEQ_TIMEOUT.value : '0;
    assign readback_array[1][28:13] = '0;
    assign readback_array[1][29:29] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.HC_CONTROL.ABORT.value : '0;
    assign readback_array[1][30:30] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.HC_CONTROL.RESUME.value : '0;
    assign readback_array[1][31:31] = (decoded_reg_strb.I3CBase.HC_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.HC_CONTROL.BUS_ENABLE.value : '0;
    assign readback_array[2][15:0] = '0;
    assign readback_array[2][22:16] = (decoded_reg_strb.I3CBase.CONTROLLER_DEVICE_ADDR && !decoded_req_is_wr) ? field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR.value : '0;
    assign readback_array[2][30:23] = '0;
    assign readback_array[2][31:31] = (decoded_reg_strb.I3CBase.CONTROLLER_DEVICE_ADDR && !decoded_req_is_wr) ? field_storage.I3CBase.CONTROLLER_DEVICE_ADDR.DYNAMIC_ADDR_VALID.value : '0;
    assign readback_array[3][1:0] = '0;
    assign readback_array[3][2:2] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][3:3] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][4:4] = '0;
    assign readback_array[3][5:5] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][6:6] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][7:7] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][9:8] = '0;
    assign readback_array[3][10:10] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h1 : '0;
    assign readback_array[3][11:11] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][12:12] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][13:13] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][19:14] = '0;
    assign readback_array[3][21:20] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 2'h0 : '0;
    assign readback_array[3][27:22] = '0;
    assign readback_array[3][28:28] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][29:29] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][30:30] = (decoded_reg_strb.I3CBase.HC_CAPABILITIES && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][31:31] = '0;
    assign readback_array[4][0:0] = (decoded_reg_strb.I3CBase.RESET_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.RESET_CONTROL.SOFT_RST.value : '0;
    assign readback_array[4][1:1] = (decoded_reg_strb.I3CBase.RESET_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.RESET_CONTROL.CMD_QUEUE_RST.value : '0;
    assign readback_array[4][2:2] = (decoded_reg_strb.I3CBase.RESET_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.RESET_CONTROL.RESP_QUEUE_RST.value : '0;
    assign readback_array[4][3:3] = (decoded_reg_strb.I3CBase.RESET_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.RESET_CONTROL.TX_FIFO_RST.value : '0;
    assign readback_array[4][4:4] = (decoded_reg_strb.I3CBase.RESET_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.RESET_CONTROL.RX_FIFO_RST.value : '0;
    assign readback_array[4][5:5] = (decoded_reg_strb.I3CBase.RESET_CONTROL && !decoded_req_is_wr) ? field_storage.I3CBase.RESET_CONTROL.IBI_QUEUE_RST.value : '0;
    assign readback_array[4][31:6] = '0;
    assign readback_array[5][1:0] = '0;
    assign readback_array[5][2:2] = (decoded_reg_strb.I3CBase.PRESENT_STATE && !decoded_req_is_wr) ? hwif_in.I3CBase.PRESENT_STATE.AC_CURRENT_OWN.next : '0;
    assign readback_array[5][31:3] = '0;
    assign readback_array[6][9:0] = '0;
    assign readback_array[6][10:10] = (decoded_reg_strb.I3CBase.INTR_STATUS && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS.HC_INTERNAL_ERR_STAT.value : '0;
    assign readback_array[6][11:11] = (decoded_reg_strb.I3CBase.INTR_STATUS && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS.HC_SEQ_CANCEL_STAT.value : '0;
    assign readback_array[6][12:12] = (decoded_reg_strb.I3CBase.INTR_STATUS && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS.HC_WARN_CMD_SEQ_STALL_STAT.value : '0;
    assign readback_array[6][13:13] = (decoded_reg_strb.I3CBase.INTR_STATUS && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS.HC_ERR_CMD_SEQ_TIMEOUT_STAT.value : '0;
    assign readback_array[6][14:14] = (decoded_reg_strb.I3CBase.INTR_STATUS && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS.SCHED_CMD_MISSED_TICK_STAT.value : '0;
    assign readback_array[6][31:15] = '0;
    assign readback_array[7][9:0] = '0;
    assign readback_array[7][10:10] = (decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS_ENABLE.HC_INTERNAL_ERR_STAT_EN.value : '0;
    assign readback_array[7][11:11] = (decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS_ENABLE.HC_SEQ_CANCEL_STAT_EN.value : '0;
    assign readback_array[7][12:12] = (decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS_ENABLE.HC_WARN_CMD_SEQ_STALL_STAT_EN.value : '0;
    assign readback_array[7][13:13] = (decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.value : '0;
    assign readback_array[7][14:14] = (decoded_reg_strb.I3CBase.INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_STATUS_ENABLE.SCHED_CMD_MISSED_TICK_STAT_EN.value : '0;
    assign readback_array[7][31:15] = '0;
    assign readback_array[8][9:0] = '0;
    assign readback_array[8][10:10] = (decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_INTERNAL_ERR_SIGNAL_EN.value : '0;
    assign readback_array[8][11:11] = (decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_SEQ_CANCEL_SIGNAL_EN.value : '0;
    assign readback_array[8][12:12] = (decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.value : '0;
    assign readback_array[8][13:13] = (decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_SIGNAL_ENABLE.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.value : '0;
    assign readback_array[8][14:14] = (decoded_reg_strb.I3CBase.INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.I3CBase.INTR_SIGNAL_ENABLE.SCHED_CMD_MISSED_TICK_SIGNAL_EN.value : '0;
    assign readback_array[8][31:15] = '0;
    assign readback_array[9][11:0] = (decoded_reg_strb.I3CBase.DAT_SECTION_OFFSET && !decoded_req_is_wr) ? 12'h400 : '0;
    assign readback_array[9][18:12] = (decoded_reg_strb.I3CBase.DAT_SECTION_OFFSET && !decoded_req_is_wr) ? 7'h1f : '0;
    assign readback_array[9][27:19] = '0;
    assign readback_array[9][31:28] = (decoded_reg_strb.I3CBase.DAT_SECTION_OFFSET && !decoded_req_is_wr) ? 4'h0 : '0;
    assign readback_array[10][11:0] = (decoded_reg_strb.I3CBase.DCT_SECTION_OFFSET && !decoded_req_is_wr) ? 12'h800 : '0;
    assign readback_array[10][18:12] = (decoded_reg_strb.I3CBase.DCT_SECTION_OFFSET && !decoded_req_is_wr) ? 7'h1f : '0;
    assign readback_array[10][23:19] = (decoded_reg_strb.I3CBase.DCT_SECTION_OFFSET && !decoded_req_is_wr) ? field_storage.I3CBase.DCT_SECTION_OFFSET.TABLE_INDEX.value : '0;
    assign readback_array[10][27:24] = '0;
    assign readback_array[10][31:28] = (decoded_reg_strb.I3CBase.DCT_SECTION_OFFSET && !decoded_req_is_wr) ? 4'h0 : '0;
    assign readback_array[11][15:0] = (decoded_reg_strb.I3CBase.RING_HEADERS_SECTION_OFFSET && !decoded_req_is_wr) ? 16'h0 : '0;
    assign readback_array[11][31:16] = '0;
    assign readback_array[12][15:0] = (decoded_reg_strb.I3CBase.PIO_SECTION_OFFSET && !decoded_req_is_wr) ? 16'h100 : '0;
    assign readback_array[12][31:16] = '0;
    assign readback_array[13][15:0] = (decoded_reg_strb.I3CBase.EXT_CAPS_SECTION_OFFSET && !decoded_req_is_wr) ? 16'h0 : '0;
    assign readback_array[13][31:16] = '0;
    assign readback_array[14][0:0] = (decoded_reg_strb.I3CBase.INT_CTRL_CMDS_EN && !decoded_req_is_wr) ? 1'h1 : '0;
    assign readback_array[14][15:1] = (decoded_reg_strb.I3CBase.INT_CTRL_CMDS_EN && !decoded_req_is_wr) ? 15'h35 : '0;
    assign readback_array[14][31:16] = '0;
    assign readback_array[15][0:0] = (decoded_reg_strb.I3CBase.IBI_NOTIFY_CTRL && !decoded_req_is_wr) ? field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_HJ_REJECTED.value : '0;
    assign readback_array[15][1:1] = (decoded_reg_strb.I3CBase.IBI_NOTIFY_CTRL && !decoded_req_is_wr) ? field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_CRR_REJECTED.value : '0;
    assign readback_array[15][2:2] = '0;
    assign readback_array[15][3:3] = (decoded_reg_strb.I3CBase.IBI_NOTIFY_CTRL && !decoded_req_is_wr) ? field_storage.I3CBase.IBI_NOTIFY_CTRL.NOTIFY_IBI_REJECTED.value : '0;
    assign readback_array[15][31:4] = '0;
    assign readback_array[16][7:0] = '0;
    assign readback_array[16][15:8] = (decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && !decoded_req_is_wr) ? field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_IBI_ID.value : '0;
    assign readback_array[16][17:16] = (decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && !decoded_req_is_wr) ? field_storage.I3CBase.IBI_DATA_ABORT_CTRL.AFTER_N_CHUNKS.value : '0;
    assign readback_array[16][20:18] = (decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && !decoded_req_is_wr) ? field_storage.I3CBase.IBI_DATA_ABORT_CTRL.MATCH_STATUS_TYPE.value : '0;
    assign readback_array[16][30:21] = '0;
    assign readback_array[16][31:31] = (decoded_reg_strb.I3CBase.IBI_DATA_ABORT_CTRL && !decoded_req_is_wr) ? field_storage.I3CBase.IBI_DATA_ABORT_CTRL.IBI_DATA_ABORT_MON.value : '0;
    assign readback_array[17][0:0] = (decoded_reg_strb.I3CBase.DEV_CTX_BASE_LO && !decoded_req_is_wr) ? field_storage.I3CBase.DEV_CTX_BASE_LO.BASE_LO.value : '0;
    assign readback_array[17][31:1] = '0;
    assign readback_array[18][0:0] = (decoded_reg_strb.I3CBase.DEV_CTX_BASE_HI && !decoded_req_is_wr) ? field_storage.I3CBase.DEV_CTX_BASE_HI.BASE_HI.value : '0;
    assign readback_array[18][31:1] = '0;
    assign readback_array[19][15:0] = (decoded_reg_strb.I3CBase.DEV_CTX_SG && !decoded_req_is_wr) ? 16'h0 : '0;
    assign readback_array[19][30:16] = '0;
    assign readback_array[19][31:31] = (decoded_reg_strb.I3CBase.DEV_CTX_SG && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[20] = hwif_in.PIOControl.RESPONSE_PORT.rd_ack ? hwif_in.PIOControl.RESPONSE_PORT.rd_data : '0;
    assign readback_array[21] = hwif_in.PIOControl.XFER_DATA_PORT.rd_ack ? hwif_in.PIOControl.XFER_DATA_PORT.rd_data : '0;
    assign readback_array[22] = hwif_in.PIOControl.IBI_PORT.rd_ack ? hwif_in.PIOControl.IBI_PORT.rd_data : '0;
    assign readback_array[23][7:0] = (decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.QUEUE_THLD_CTRL.CMD_EMPTY_BUF_THLD.value : '0;
    assign readback_array[23][15:8] = (decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.QUEUE_THLD_CTRL.RESP_BUF_THLD.value : '0;
    assign readback_array[23][23:16] = (decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_DATA_SEGMENT_SIZE.value : '0;
    assign readback_array[23][31:24] = (decoded_reg_strb.PIOControl.QUEUE_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.QUEUE_THLD_CTRL.IBI_STATUS_THLD.value : '0;
    assign readback_array[24][2:0] = (decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_BUF_THLD.value : '0;
    assign readback_array[24][7:3] = '0;
    assign readback_array[24][10:8] = (decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_BUF_THLD.value : '0;
    assign readback_array[24][15:11] = '0;
    assign readback_array[24][18:16] = (decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.TX_START_THLD.value : '0;
    assign readback_array[24][23:19] = '0;
    assign readback_array[24][26:24] = (decoded_reg_strb.PIOControl.DATA_BUFFER_THLD_CTRL && !decoded_req_is_wr) ? field_storage.PIOControl.DATA_BUFFER_THLD_CTRL.RX_START_THLD.value : '0;
    assign readback_array[24][31:27] = '0;
    assign readback_array[25][7:0] = (decoded_reg_strb.PIOControl.QUEUE_SIZE && !decoded_req_is_wr) ? 8'h40 : '0;
    assign readback_array[25][15:8] = (decoded_reg_strb.PIOControl.QUEUE_SIZE && !decoded_req_is_wr) ? 8'h40 : '0;
    assign readback_array[25][23:16] = (decoded_reg_strb.PIOControl.QUEUE_SIZE && !decoded_req_is_wr) ? 8'h5 : '0;
    assign readback_array[25][31:24] = (decoded_reg_strb.PIOControl.QUEUE_SIZE && !decoded_req_is_wr) ? 8'h5 : '0;
    assign readback_array[26][7:0] = (decoded_reg_strb.PIOControl.ALT_QUEUE_SIZE && !decoded_req_is_wr) ? 8'h40 : '0;
    assign readback_array[26][23:8] = '0;
    assign readback_array[26][24:24] = (decoded_reg_strb.PIOControl.ALT_QUEUE_SIZE && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[26][27:25] = '0;
    assign readback_array[26][28:28] = (decoded_reg_strb.PIOControl.ALT_QUEUE_SIZE && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[26][31:29] = '0;
    assign readback_array[27][0:0] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS.TX_THLD_STAT.value : '0;
    assign readback_array[27][1:1] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS.RX_THLD_STAT.value : '0;
    assign readback_array[27][2:2] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS.IBI_STATUS_THLD_STAT.value : '0;
    assign readback_array[27][3:3] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS.CMD_QUEUE_READY_STAT.value : '0;
    assign readback_array[27][4:4] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS.RESP_READY_STAT.value : '0;
    assign readback_array[27][5:5] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ABORT_STAT.value : '0;
    assign readback_array[27][8:6] = '0;
    assign readback_array[27][9:9] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS.TRANSFER_ERR_STAT.value : '0;
    assign readback_array[27][31:10] = '0;
    assign readback_array[28][0:0] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TX_THLD_STAT_EN.value : '0;
    assign readback_array[28][1:1] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RX_THLD_STAT_EN.value : '0;
    assign readback_array[28][2:2] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.IBI_STATUS_THLD_STAT_EN.value : '0;
    assign readback_array[28][3:3] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.CMD_QUEUE_READY_STAT_EN.value : '0;
    assign readback_array[28][4:4] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.RESP_READY_STAT_EN.value : '0;
    assign readback_array[28][5:5] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ABORT_STAT_EN.value : '0;
    assign readback_array[28][8:6] = '0;
    assign readback_array[28][9:9] = (decoded_reg_strb.PIOControl.PIO_INTR_STATUS_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_STATUS_ENABLE.TRANSFER_ERR_STAT_EN.value : '0;
    assign readback_array[28][31:10] = '0;
    assign readback_array[29][0:0] = (decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TX_THLD_SIGNAL_EN.value : '0;
    assign readback_array[29][1:1] = (decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RX_THLD_SIGNAL_EN.value : '0;
    assign readback_array[29][2:2] = (decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.IBI_STATUS_THLD_SIGNAL_EN.value : '0;
    assign readback_array[29][3:3] = (decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.CMD_QUEUE_READY_SIGNAL_EN.value : '0;
    assign readback_array[29][4:4] = (decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.RESP_READY_SIGNAL_EN.value : '0;
    assign readback_array[29][5:5] = (decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ABORT_SIGNAL_EN.value : '0;
    assign readback_array[29][8:6] = '0;
    assign readback_array[29][9:9] = (decoded_reg_strb.PIOControl.PIO_INTR_SIGNAL_ENABLE && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_INTR_SIGNAL_ENABLE.TRANSFER_ERR_SIGNAL_EN.value : '0;
    assign readback_array[29][31:10] = '0;
    assign readback_array[30][0:0] = (decoded_reg_strb.PIOControl.PIO_CONTROL && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_CONTROL.ENABLE.value : '0;
    assign readback_array[30][1:1] = (decoded_reg_strb.PIOControl.PIO_CONTROL && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_CONTROL.RS.value : '0;
    assign readback_array[30][2:2] = (decoded_reg_strb.PIOControl.PIO_CONTROL && !decoded_req_is_wr) ? field_storage.PIOControl.PIO_CONTROL.ABORT.value : '0;
    assign readback_array[30][31:3] = '0;
    assign readback_array[31] = hwif_in.DAT.rd_ack ? hwif_in.DAT.rd_data : '0;
    assign readback_array[32] = hwif_in.DCT.rd_ack ? hwif_in.DCT.rd_data : '0;

    // Reduce the array
    always_comb begin
        automatic logic [31:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr & ~decoded_strb_is_external;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<33; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign external_rd_ack = readback_external_rd_ack;
    assign cpuif_rd_ack = readback_done | readback_external_rd_ack;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
