
// This file was autogenerated by PeakRDL-uvm
package registers_uvm;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    `include "I3CCSR_covergroups.svh"
    // Reg - I3CCSR.I3CBase.HCI_VERSION
    class I3CCSR__I3CBase__HCI_VERSION extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__HCI_VERSION_bit_cg [32-1:0]VERSION_bit_cg;
        I3CCSR__I3CBase__HCI_VERSION_fld_cg fld_cg;
        rand uvm_reg_field VERSION;

        function new(string name = "I3CCSR__I3CBase__HCI_VERSION");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.VERSION = new("VERSION");
            this.VERSION.configure(this, 32, 0, "RO", 0, 'h120, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(VERSION_bit_cg[bt]) VERSION_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__HCI_VERSION

    // Reg - I3CCSR.I3CBase.HC_CONTROL
    class I3CCSR__I3CBase__HC_CONTROL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]IBA_INCLUDE_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]AUTOCMD_DATA_RPT_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]DATA_BYTE_ORDER_MODE_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]MODE_SELECTOR_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]I2C_DEV_PRESENT_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]HOT_JOIN_CTRL_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]HALT_ON_CMD_SEQ_TIMEOUT_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]ABORT_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]RESUME_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_bit_cg [1-1:0]BUS_ENABLE_bit_cg;
        I3CCSR__I3CBase__HC_CONTROL_fld_cg fld_cg;
        rand uvm_reg_field IBA_INCLUDE;
        rand uvm_reg_field AUTOCMD_DATA_RPT;
        rand uvm_reg_field DATA_BYTE_ORDER_MODE;
        rand uvm_reg_field MODE_SELECTOR;
        rand uvm_reg_field I2C_DEV_PRESENT;
        rand uvm_reg_field HOT_JOIN_CTRL;
        rand uvm_reg_field HALT_ON_CMD_SEQ_TIMEOUT;
        rand uvm_reg_field ABORT;
        rand uvm_reg_field RESUME;
        rand uvm_reg_field BUS_ENABLE;

        function new(string name = "I3CCSR__I3CBase__HC_CONTROL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.IBA_INCLUDE = new("IBA_INCLUDE");
            this.IBA_INCLUDE.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.AUTOCMD_DATA_RPT = new("AUTOCMD_DATA_RPT");
            this.AUTOCMD_DATA_RPT.configure(this, 1, 3, "RO", 0, 'h0, 1, 1, 0);
            this.DATA_BYTE_ORDER_MODE = new("DATA_BYTE_ORDER_MODE");
            this.DATA_BYTE_ORDER_MODE.configure(this, 1, 4, "RO", 0, 'h0, 1, 1, 0);
            this.MODE_SELECTOR = new("MODE_SELECTOR");
            this.MODE_SELECTOR.configure(this, 1, 6, "RO", 0, 'h1, 1, 1, 0);
            this.I2C_DEV_PRESENT = new("I2C_DEV_PRESENT");
            this.I2C_DEV_PRESENT.configure(this, 1, 7, "RW", 0, 'h0, 1, 1, 0);
            this.HOT_JOIN_CTRL = new("HOT_JOIN_CTRL");
            this.HOT_JOIN_CTRL.configure(this, 1, 8, "RW", 0, 'h0, 1, 1, 0);
            this.HALT_ON_CMD_SEQ_TIMEOUT = new("HALT_ON_CMD_SEQ_TIMEOUT");
            this.HALT_ON_CMD_SEQ_TIMEOUT.configure(this, 1, 12, "RW", 0, 'h0, 1, 1, 0);
            this.ABORT = new("ABORT");
            this.ABORT.configure(this, 1, 29, "RW", 0, 'h0, 1, 1, 0);
            this.RESUME = new("RESUME");
            this.RESUME.configure(this, 1, 30, "W1C", 1, 'h0, 1, 1, 0);
            this.BUS_ENABLE = new("BUS_ENABLE");
            this.BUS_ENABLE.configure(this, 1, 31, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(IBA_INCLUDE_bit_cg[bt]) IBA_INCLUDE_bit_cg[bt] = new();
                foreach(AUTOCMD_DATA_RPT_bit_cg[bt]) AUTOCMD_DATA_RPT_bit_cg[bt] = new();
                foreach(DATA_BYTE_ORDER_MODE_bit_cg[bt]) DATA_BYTE_ORDER_MODE_bit_cg[bt] = new();
                foreach(MODE_SELECTOR_bit_cg[bt]) MODE_SELECTOR_bit_cg[bt] = new();
                foreach(I2C_DEV_PRESENT_bit_cg[bt]) I2C_DEV_PRESENT_bit_cg[bt] = new();
                foreach(HOT_JOIN_CTRL_bit_cg[bt]) HOT_JOIN_CTRL_bit_cg[bt] = new();
                foreach(HALT_ON_CMD_SEQ_TIMEOUT_bit_cg[bt]) HALT_ON_CMD_SEQ_TIMEOUT_bit_cg[bt] = new();
                foreach(ABORT_bit_cg[bt]) ABORT_bit_cg[bt] = new();
                foreach(RESUME_bit_cg[bt]) RESUME_bit_cg[bt] = new();
                foreach(BUS_ENABLE_bit_cg[bt]) BUS_ENABLE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__HC_CONTROL

    // Reg - I3CCSR.I3CBase.CONTROLLER_DEVICE_ADDR
    class I3CCSR__I3CBase__CONTROLLER_DEVICE_ADDR extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__CONTROLLER_DEVICE_ADDR_bit_cg [7-1:0]DYNAMIC_ADDR_bit_cg;
        I3CCSR__I3CBase__CONTROLLER_DEVICE_ADDR_bit_cg [1-1:0]DYNAMIC_ADDR_VALID_bit_cg;
        I3CCSR__I3CBase__CONTROLLER_DEVICE_ADDR_fld_cg fld_cg;
        rand uvm_reg_field DYNAMIC_ADDR;
        rand uvm_reg_field DYNAMIC_ADDR_VALID;

        function new(string name = "I3CCSR__I3CBase__CONTROLLER_DEVICE_ADDR");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.DYNAMIC_ADDR = new("DYNAMIC_ADDR");
            this.DYNAMIC_ADDR.configure(this, 7, 16, "RW", 1, 'h0, 1, 1, 0);
            this.DYNAMIC_ADDR_VALID = new("DYNAMIC_ADDR_VALID");
            this.DYNAMIC_ADDR_VALID.configure(this, 1, 31, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(DYNAMIC_ADDR_bit_cg[bt]) DYNAMIC_ADDR_bit_cg[bt] = new();
                foreach(DYNAMIC_ADDR_VALID_bit_cg[bt]) DYNAMIC_ADDR_VALID_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__CONTROLLER_DEVICE_ADDR

    // Reg - I3CCSR.I3CBase.HC_CAPABILITIES
    class I3CCSR__I3CBase__HC_CAPABILITIES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]COMBO_COMMAND_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]AUTO_COMMAND_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]STANDBY_CR_CAP_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]HDR_DDR_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]HDR_TS_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]CMD_CCC_DEFBYTE_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]IBI_DATA_ABORT_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]IBI_CREDIT_COUNT_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]SCHEDULED_COMMANDS_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [2-1:0]CMD_SIZE_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]SG_CAPABILITY_CR_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]SG_CAPABILITY_IBI_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_bit_cg [1-1:0]SG_CAPABILITY_DC_EN_bit_cg;
        I3CCSR__I3CBase__HC_CAPABILITIES_fld_cg fld_cg;
        rand uvm_reg_field COMBO_COMMAND;
        rand uvm_reg_field AUTO_COMMAND;
        rand uvm_reg_field STANDBY_CR_CAP;
        rand uvm_reg_field HDR_DDR_EN;
        rand uvm_reg_field HDR_TS_EN;
        rand uvm_reg_field CMD_CCC_DEFBYTE;
        rand uvm_reg_field IBI_DATA_ABORT_EN;
        rand uvm_reg_field IBI_CREDIT_COUNT_EN;
        rand uvm_reg_field SCHEDULED_COMMANDS_EN;
        rand uvm_reg_field CMD_SIZE;
        rand uvm_reg_field SG_CAPABILITY_CR_EN;
        rand uvm_reg_field SG_CAPABILITY_IBI_EN;
        rand uvm_reg_field SG_CAPABILITY_DC_EN;

        function new(string name = "I3CCSR__I3CBase__HC_CAPABILITIES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.COMBO_COMMAND = new("COMBO_COMMAND");
            this.COMBO_COMMAND.configure(this, 1, 2, "RO", 0, 'h0, 1, 1, 0);
            this.AUTO_COMMAND = new("AUTO_COMMAND");
            this.AUTO_COMMAND.configure(this, 1, 3, "RO", 0, 'h0, 1, 1, 0);
            this.STANDBY_CR_CAP = new("STANDBY_CR_CAP");
            this.STANDBY_CR_CAP.configure(this, 1, 5, "RO", 0, 'h0, 1, 1, 0);
            this.HDR_DDR_EN = new("HDR_DDR_EN");
            this.HDR_DDR_EN.configure(this, 1, 6, "RO", 0, 'h0, 1, 1, 0);
            this.HDR_TS_EN = new("HDR_TS_EN");
            this.HDR_TS_EN.configure(this, 1, 7, "RO", 0, 'h0, 1, 1, 0);
            this.CMD_CCC_DEFBYTE = new("CMD_CCC_DEFBYTE");
            this.CMD_CCC_DEFBYTE.configure(this, 1, 10, "RO", 0, 'h1, 1, 1, 0);
            this.IBI_DATA_ABORT_EN = new("IBI_DATA_ABORT_EN");
            this.IBI_DATA_ABORT_EN.configure(this, 1, 11, "RO", 0, 'h0, 1, 1, 0);
            this.IBI_CREDIT_COUNT_EN = new("IBI_CREDIT_COUNT_EN");
            this.IBI_CREDIT_COUNT_EN.configure(this, 1, 12, "RO", 0, 'h0, 1, 1, 0);
            this.SCHEDULED_COMMANDS_EN = new("SCHEDULED_COMMANDS_EN");
            this.SCHEDULED_COMMANDS_EN.configure(this, 1, 13, "RO", 0, 'h0, 1, 1, 0);
            this.CMD_SIZE = new("CMD_SIZE");
            this.CMD_SIZE.configure(this, 2, 20, "RO", 0, 'h0, 1, 1, 0);
            this.SG_CAPABILITY_CR_EN = new("SG_CAPABILITY_CR_EN");
            this.SG_CAPABILITY_CR_EN.configure(this, 1, 28, "RO", 0, 'h0, 1, 1, 0);
            this.SG_CAPABILITY_IBI_EN = new("SG_CAPABILITY_IBI_EN");
            this.SG_CAPABILITY_IBI_EN.configure(this, 1, 29, "RO", 0, 'h0, 1, 1, 0);
            this.SG_CAPABILITY_DC_EN = new("SG_CAPABILITY_DC_EN");
            this.SG_CAPABILITY_DC_EN.configure(this, 1, 30, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(COMBO_COMMAND_bit_cg[bt]) COMBO_COMMAND_bit_cg[bt] = new();
                foreach(AUTO_COMMAND_bit_cg[bt]) AUTO_COMMAND_bit_cg[bt] = new();
                foreach(STANDBY_CR_CAP_bit_cg[bt]) STANDBY_CR_CAP_bit_cg[bt] = new();
                foreach(HDR_DDR_EN_bit_cg[bt]) HDR_DDR_EN_bit_cg[bt] = new();
                foreach(HDR_TS_EN_bit_cg[bt]) HDR_TS_EN_bit_cg[bt] = new();
                foreach(CMD_CCC_DEFBYTE_bit_cg[bt]) CMD_CCC_DEFBYTE_bit_cg[bt] = new();
                foreach(IBI_DATA_ABORT_EN_bit_cg[bt]) IBI_DATA_ABORT_EN_bit_cg[bt] = new();
                foreach(IBI_CREDIT_COUNT_EN_bit_cg[bt]) IBI_CREDIT_COUNT_EN_bit_cg[bt] = new();
                foreach(SCHEDULED_COMMANDS_EN_bit_cg[bt]) SCHEDULED_COMMANDS_EN_bit_cg[bt] = new();
                foreach(CMD_SIZE_bit_cg[bt]) CMD_SIZE_bit_cg[bt] = new();
                foreach(SG_CAPABILITY_CR_EN_bit_cg[bt]) SG_CAPABILITY_CR_EN_bit_cg[bt] = new();
                foreach(SG_CAPABILITY_IBI_EN_bit_cg[bt]) SG_CAPABILITY_IBI_EN_bit_cg[bt] = new();
                foreach(SG_CAPABILITY_DC_EN_bit_cg[bt]) SG_CAPABILITY_DC_EN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__HC_CAPABILITIES

    // Reg - I3CCSR.I3CBase.RESET_CONTROL
    class I3CCSR__I3CBase__RESET_CONTROL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__RESET_CONTROL_bit_cg [1-1:0]SOFT_RST_bit_cg;
        I3CCSR__I3CBase__RESET_CONTROL_bit_cg [1-1:0]CMD_QUEUE_RST_bit_cg;
        I3CCSR__I3CBase__RESET_CONTROL_bit_cg [1-1:0]RESP_QUEUE_RST_bit_cg;
        I3CCSR__I3CBase__RESET_CONTROL_bit_cg [1-1:0]TX_FIFO_RST_bit_cg;
        I3CCSR__I3CBase__RESET_CONTROL_bit_cg [1-1:0]RX_FIFO_RST_bit_cg;
        I3CCSR__I3CBase__RESET_CONTROL_bit_cg [1-1:0]IBI_QUEUE_RST_bit_cg;
        I3CCSR__I3CBase__RESET_CONTROL_fld_cg fld_cg;
        rand uvm_reg_field SOFT_RST;
        rand uvm_reg_field CMD_QUEUE_RST;
        rand uvm_reg_field RESP_QUEUE_RST;
        rand uvm_reg_field TX_FIFO_RST;
        rand uvm_reg_field RX_FIFO_RST;
        rand uvm_reg_field IBI_QUEUE_RST;

        function new(string name = "I3CCSR__I3CBase__RESET_CONTROL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.SOFT_RST = new("SOFT_RST");
            this.SOFT_RST.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            this.CMD_QUEUE_RST = new("CMD_QUEUE_RST");
            this.CMD_QUEUE_RST.configure(this, 1, 1, "RW", 1, 'h0, 1, 1, 0);
            this.RESP_QUEUE_RST = new("RESP_QUEUE_RST");
            this.RESP_QUEUE_RST.configure(this, 1, 2, "RW", 1, 'h0, 1, 1, 0);
            this.TX_FIFO_RST = new("TX_FIFO_RST");
            this.TX_FIFO_RST.configure(this, 1, 3, "RW", 1, 'h0, 1, 1, 0);
            this.RX_FIFO_RST = new("RX_FIFO_RST");
            this.RX_FIFO_RST.configure(this, 1, 4, "RW", 1, 'h0, 1, 1, 0);
            this.IBI_QUEUE_RST = new("IBI_QUEUE_RST");
            this.IBI_QUEUE_RST.configure(this, 1, 5, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(SOFT_RST_bit_cg[bt]) SOFT_RST_bit_cg[bt] = new();
                foreach(CMD_QUEUE_RST_bit_cg[bt]) CMD_QUEUE_RST_bit_cg[bt] = new();
                foreach(RESP_QUEUE_RST_bit_cg[bt]) RESP_QUEUE_RST_bit_cg[bt] = new();
                foreach(TX_FIFO_RST_bit_cg[bt]) TX_FIFO_RST_bit_cg[bt] = new();
                foreach(RX_FIFO_RST_bit_cg[bt]) RX_FIFO_RST_bit_cg[bt] = new();
                foreach(IBI_QUEUE_RST_bit_cg[bt]) IBI_QUEUE_RST_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__RESET_CONTROL

    // Reg - I3CCSR.I3CBase.PRESENT_STATE
    class I3CCSR__I3CBase__PRESENT_STATE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__PRESENT_STATE_bit_cg [1-1:0]AC_CURRENT_OWN_bit_cg;
        I3CCSR__I3CBase__PRESENT_STATE_fld_cg fld_cg;
        rand uvm_reg_field AC_CURRENT_OWN;

        function new(string name = "I3CCSR__I3CBase__PRESENT_STATE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.AC_CURRENT_OWN = new("AC_CURRENT_OWN");
            this.AC_CURRENT_OWN.configure(this, 1, 2, "RO", 1, 'h1, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(AC_CURRENT_OWN_bit_cg[bt]) AC_CURRENT_OWN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__PRESENT_STATE

    // Reg - I3CCSR.I3CBase.INTR_STATUS
    class I3CCSR__I3CBase__INTR_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__INTR_STATUS_bit_cg [1-1:0]HC_INTERNAL_ERR_STAT_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_bit_cg [1-1:0]HC_SEQ_CANCEL_STAT_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_bit_cg [1-1:0]HC_WARN_CMD_SEQ_STALL_STAT_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_bit_cg [1-1:0]HC_ERR_CMD_SEQ_TIMEOUT_STAT_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_bit_cg [1-1:0]SCHED_CMD_MISSED_TICK_STAT_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_fld_cg fld_cg;
        rand uvm_reg_field HC_INTERNAL_ERR_STAT;
        rand uvm_reg_field HC_SEQ_CANCEL_STAT;
        rand uvm_reg_field HC_WARN_CMD_SEQ_STALL_STAT;
        rand uvm_reg_field HC_ERR_CMD_SEQ_TIMEOUT_STAT;
        rand uvm_reg_field SCHED_CMD_MISSED_TICK_STAT;

        function new(string name = "I3CCSR__I3CBase__INTR_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.HC_INTERNAL_ERR_STAT = new("HC_INTERNAL_ERR_STAT");
            this.HC_INTERNAL_ERR_STAT.configure(this, 1, 10, "W1C", 1, 'h0, 1, 1, 0);
            this.HC_SEQ_CANCEL_STAT = new("HC_SEQ_CANCEL_STAT");
            this.HC_SEQ_CANCEL_STAT.configure(this, 1, 11, "W1C", 1, 'h0, 1, 1, 0);
            this.HC_WARN_CMD_SEQ_STALL_STAT = new("HC_WARN_CMD_SEQ_STALL_STAT");
            this.HC_WARN_CMD_SEQ_STALL_STAT.configure(this, 1, 12, "W1C", 1, 'h0, 1, 1, 0);
            this.HC_ERR_CMD_SEQ_TIMEOUT_STAT = new("HC_ERR_CMD_SEQ_TIMEOUT_STAT");
            this.HC_ERR_CMD_SEQ_TIMEOUT_STAT.configure(this, 1, 13, "W1C", 1, 'h0, 1, 1, 0);
            this.SCHED_CMD_MISSED_TICK_STAT = new("SCHED_CMD_MISSED_TICK_STAT");
            this.SCHED_CMD_MISSED_TICK_STAT.configure(this, 1, 14, "W1C", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(HC_INTERNAL_ERR_STAT_bit_cg[bt]) HC_INTERNAL_ERR_STAT_bit_cg[bt] = new();
                foreach(HC_SEQ_CANCEL_STAT_bit_cg[bt]) HC_SEQ_CANCEL_STAT_bit_cg[bt] = new();
                foreach(HC_WARN_CMD_SEQ_STALL_STAT_bit_cg[bt]) HC_WARN_CMD_SEQ_STALL_STAT_bit_cg[bt] = new();
                foreach(HC_ERR_CMD_SEQ_TIMEOUT_STAT_bit_cg[bt]) HC_ERR_CMD_SEQ_TIMEOUT_STAT_bit_cg[bt] = new();
                foreach(SCHED_CMD_MISSED_TICK_STAT_bit_cg[bt]) SCHED_CMD_MISSED_TICK_STAT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__INTR_STATUS

    // Reg - I3CCSR.I3CBase.INTR_STATUS_ENABLE
    class I3CCSR__I3CBase__INTR_STATUS_ENABLE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__INTR_STATUS_ENABLE_bit_cg [1-1:0]HC_INTERNAL_ERR_STAT_EN_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_ENABLE_bit_cg [1-1:0]HC_SEQ_CANCEL_STAT_EN_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_ENABLE_bit_cg [1-1:0]HC_WARN_CMD_SEQ_STALL_STAT_EN_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_ENABLE_bit_cg [1-1:0]HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_ENABLE_bit_cg [1-1:0]SCHED_CMD_MISSED_TICK_STAT_EN_bit_cg;
        I3CCSR__I3CBase__INTR_STATUS_ENABLE_fld_cg fld_cg;
        rand uvm_reg_field HC_INTERNAL_ERR_STAT_EN;
        rand uvm_reg_field HC_SEQ_CANCEL_STAT_EN;
        rand uvm_reg_field HC_WARN_CMD_SEQ_STALL_STAT_EN;
        rand uvm_reg_field HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN;
        rand uvm_reg_field SCHED_CMD_MISSED_TICK_STAT_EN;

        function new(string name = "I3CCSR__I3CBase__INTR_STATUS_ENABLE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.HC_INTERNAL_ERR_STAT_EN = new("HC_INTERNAL_ERR_STAT_EN");
            this.HC_INTERNAL_ERR_STAT_EN.configure(this, 1, 10, "RW", 0, 'h0, 1, 1, 0);
            this.HC_SEQ_CANCEL_STAT_EN = new("HC_SEQ_CANCEL_STAT_EN");
            this.HC_SEQ_CANCEL_STAT_EN.configure(this, 1, 11, "RW", 0, 'h0, 1, 1, 0);
            this.HC_WARN_CMD_SEQ_STALL_STAT_EN = new("HC_WARN_CMD_SEQ_STALL_STAT_EN");
            this.HC_WARN_CMD_SEQ_STALL_STAT_EN.configure(this, 1, 12, "RW", 0, 'h0, 1, 1, 0);
            this.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN = new("HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN");
            this.HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN.configure(this, 1, 13, "RW", 0, 'h0, 1, 1, 0);
            this.SCHED_CMD_MISSED_TICK_STAT_EN = new("SCHED_CMD_MISSED_TICK_STAT_EN");
            this.SCHED_CMD_MISSED_TICK_STAT_EN.configure(this, 1, 14, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(HC_INTERNAL_ERR_STAT_EN_bit_cg[bt]) HC_INTERNAL_ERR_STAT_EN_bit_cg[bt] = new();
                foreach(HC_SEQ_CANCEL_STAT_EN_bit_cg[bt]) HC_SEQ_CANCEL_STAT_EN_bit_cg[bt] = new();
                foreach(HC_WARN_CMD_SEQ_STALL_STAT_EN_bit_cg[bt]) HC_WARN_CMD_SEQ_STALL_STAT_EN_bit_cg[bt] = new();
                foreach(HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN_bit_cg[bt]) HC_ERR_CMD_SEQ_TIMEOUT_STAT_EN_bit_cg[bt] = new();
                foreach(SCHED_CMD_MISSED_TICK_STAT_EN_bit_cg[bt]) SCHED_CMD_MISSED_TICK_STAT_EN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__INTR_STATUS_ENABLE

    // Reg - I3CCSR.I3CBase.INTR_SIGNAL_ENABLE
    class I3CCSR__I3CBase__INTR_SIGNAL_ENABLE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__INTR_SIGNAL_ENABLE_bit_cg [1-1:0]HC_INTERNAL_ERR_SIGNAL_EN_bit_cg;
        I3CCSR__I3CBase__INTR_SIGNAL_ENABLE_bit_cg [1-1:0]HC_SEQ_CANCEL_SIGNAL_EN_bit_cg;
        I3CCSR__I3CBase__INTR_SIGNAL_ENABLE_bit_cg [1-1:0]HC_WARN_CMD_SEQ_STALL_SIGNAL_EN_bit_cg;
        I3CCSR__I3CBase__INTR_SIGNAL_ENABLE_bit_cg [1-1:0]HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN_bit_cg;
        I3CCSR__I3CBase__INTR_SIGNAL_ENABLE_bit_cg [1-1:0]SCHED_CMD_MISSED_TICK_SIGNAL_EN_bit_cg;
        I3CCSR__I3CBase__INTR_SIGNAL_ENABLE_fld_cg fld_cg;
        rand uvm_reg_field HC_INTERNAL_ERR_SIGNAL_EN;
        rand uvm_reg_field HC_SEQ_CANCEL_SIGNAL_EN;
        rand uvm_reg_field HC_WARN_CMD_SEQ_STALL_SIGNAL_EN;
        rand uvm_reg_field HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN;
        rand uvm_reg_field SCHED_CMD_MISSED_TICK_SIGNAL_EN;

        function new(string name = "I3CCSR__I3CBase__INTR_SIGNAL_ENABLE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.HC_INTERNAL_ERR_SIGNAL_EN = new("HC_INTERNAL_ERR_SIGNAL_EN");
            this.HC_INTERNAL_ERR_SIGNAL_EN.configure(this, 1, 10, "RW", 0, 'h0, 1, 1, 0);
            this.HC_SEQ_CANCEL_SIGNAL_EN = new("HC_SEQ_CANCEL_SIGNAL_EN");
            this.HC_SEQ_CANCEL_SIGNAL_EN.configure(this, 1, 11, "RW", 0, 'h0, 1, 1, 0);
            this.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN = new("HC_WARN_CMD_SEQ_STALL_SIGNAL_EN");
            this.HC_WARN_CMD_SEQ_STALL_SIGNAL_EN.configure(this, 1, 12, "RW", 0, 'h0, 1, 1, 0);
            this.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN = new("HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN");
            this.HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN.configure(this, 1, 13, "RW", 0, 'h0, 1, 1, 0);
            this.SCHED_CMD_MISSED_TICK_SIGNAL_EN = new("SCHED_CMD_MISSED_TICK_SIGNAL_EN");
            this.SCHED_CMD_MISSED_TICK_SIGNAL_EN.configure(this, 1, 14, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(HC_INTERNAL_ERR_SIGNAL_EN_bit_cg[bt]) HC_INTERNAL_ERR_SIGNAL_EN_bit_cg[bt] = new();
                foreach(HC_SEQ_CANCEL_SIGNAL_EN_bit_cg[bt]) HC_SEQ_CANCEL_SIGNAL_EN_bit_cg[bt] = new();
                foreach(HC_WARN_CMD_SEQ_STALL_SIGNAL_EN_bit_cg[bt]) HC_WARN_CMD_SEQ_STALL_SIGNAL_EN_bit_cg[bt] = new();
                foreach(HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN_bit_cg[bt]) HC_ERR_CMD_SEQ_TIMEOUT_SIGNAL_EN_bit_cg[bt] = new();
                foreach(SCHED_CMD_MISSED_TICK_SIGNAL_EN_bit_cg[bt]) SCHED_CMD_MISSED_TICK_SIGNAL_EN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__INTR_SIGNAL_ENABLE

    // Reg - I3CCSR.I3CBase.INTR_FORCE
    class I3CCSR__I3CBase__INTR_FORCE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__INTR_FORCE_bit_cg [1-1:0]HC_INTERNAL_ERR_FORCE_bit_cg;
        I3CCSR__I3CBase__INTR_FORCE_bit_cg [1-1:0]HC_SEQ_CANCEL_FORCE_bit_cg;
        I3CCSR__I3CBase__INTR_FORCE_bit_cg [1-1:0]HC_WARN_CMD_SEQ_STALL_FORCE_bit_cg;
        I3CCSR__I3CBase__INTR_FORCE_bit_cg [1-1:0]HC_ERR_CMD_SEQ_TIMEOUT_FORCE_bit_cg;
        I3CCSR__I3CBase__INTR_FORCE_bit_cg [1-1:0]SCHED_CMD_MISSED_TICK_FORCE_bit_cg;
        I3CCSR__I3CBase__INTR_FORCE_fld_cg fld_cg;
        rand uvm_reg_field HC_INTERNAL_ERR_FORCE;
        rand uvm_reg_field HC_SEQ_CANCEL_FORCE;
        rand uvm_reg_field HC_WARN_CMD_SEQ_STALL_FORCE;
        rand uvm_reg_field HC_ERR_CMD_SEQ_TIMEOUT_FORCE;
        rand uvm_reg_field SCHED_CMD_MISSED_TICK_FORCE;

        function new(string name = "I3CCSR__I3CBase__INTR_FORCE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.HC_INTERNAL_ERR_FORCE = new("HC_INTERNAL_ERR_FORCE");
            this.HC_INTERNAL_ERR_FORCE.configure(this, 1, 10, "WO", 0, 'h0, 1, 1, 0);
            this.HC_SEQ_CANCEL_FORCE = new("HC_SEQ_CANCEL_FORCE");
            this.HC_SEQ_CANCEL_FORCE.configure(this, 1, 11, "WO", 0, 'h0, 1, 1, 0);
            this.HC_WARN_CMD_SEQ_STALL_FORCE = new("HC_WARN_CMD_SEQ_STALL_FORCE");
            this.HC_WARN_CMD_SEQ_STALL_FORCE.configure(this, 1, 12, "WO", 0, 'h0, 1, 1, 0);
            this.HC_ERR_CMD_SEQ_TIMEOUT_FORCE = new("HC_ERR_CMD_SEQ_TIMEOUT_FORCE");
            this.HC_ERR_CMD_SEQ_TIMEOUT_FORCE.configure(this, 1, 13, "WO", 0, 'h0, 1, 1, 0);
            this.SCHED_CMD_MISSED_TICK_FORCE = new("SCHED_CMD_MISSED_TICK_FORCE");
            this.SCHED_CMD_MISSED_TICK_FORCE.configure(this, 1, 14, "WO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(HC_INTERNAL_ERR_FORCE_bit_cg[bt]) HC_INTERNAL_ERR_FORCE_bit_cg[bt] = new();
                foreach(HC_SEQ_CANCEL_FORCE_bit_cg[bt]) HC_SEQ_CANCEL_FORCE_bit_cg[bt] = new();
                foreach(HC_WARN_CMD_SEQ_STALL_FORCE_bit_cg[bt]) HC_WARN_CMD_SEQ_STALL_FORCE_bit_cg[bt] = new();
                foreach(HC_ERR_CMD_SEQ_TIMEOUT_FORCE_bit_cg[bt]) HC_ERR_CMD_SEQ_TIMEOUT_FORCE_bit_cg[bt] = new();
                foreach(SCHED_CMD_MISSED_TICK_FORCE_bit_cg[bt]) SCHED_CMD_MISSED_TICK_FORCE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__INTR_FORCE

    // Reg - I3CCSR.I3CBase.DAT_SECTION_OFFSET
    class I3CCSR__I3CBase__DAT_SECTION_OFFSET extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__DAT_SECTION_OFFSET_bit_cg [12-1:0]TABLE_OFFSET_bit_cg;
        I3CCSR__I3CBase__DAT_SECTION_OFFSET_bit_cg [7-1:0]TABLE_SIZE_bit_cg;
        I3CCSR__I3CBase__DAT_SECTION_OFFSET_bit_cg [4-1:0]ENTRY_SIZE_bit_cg;
        I3CCSR__I3CBase__DAT_SECTION_OFFSET_fld_cg fld_cg;
        rand uvm_reg_field TABLE_OFFSET;
        rand uvm_reg_field TABLE_SIZE;
        rand uvm_reg_field ENTRY_SIZE;

        function new(string name = "I3CCSR__I3CBase__DAT_SECTION_OFFSET");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TABLE_OFFSET = new("TABLE_OFFSET");
            this.TABLE_OFFSET.configure(this, 12, 0, "RO", 0, 'h400, 1, 1, 0);
            this.TABLE_SIZE = new("TABLE_SIZE");
            this.TABLE_SIZE.configure(this, 7, 12, "RO", 0, 'h7f, 1, 1, 0);
            this.ENTRY_SIZE = new("ENTRY_SIZE");
            this.ENTRY_SIZE.configure(this, 4, 28, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TABLE_OFFSET_bit_cg[bt]) TABLE_OFFSET_bit_cg[bt] = new();
                foreach(TABLE_SIZE_bit_cg[bt]) TABLE_SIZE_bit_cg[bt] = new();
                foreach(ENTRY_SIZE_bit_cg[bt]) ENTRY_SIZE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__DAT_SECTION_OFFSET

    // Reg - I3CCSR.I3CBase.DCT_SECTION_OFFSET
    class I3CCSR__I3CBase__DCT_SECTION_OFFSET extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__DCT_SECTION_OFFSET_bit_cg [12-1:0]TABLE_OFFSET_bit_cg;
        I3CCSR__I3CBase__DCT_SECTION_OFFSET_bit_cg [7-1:0]TABLE_SIZE_bit_cg;
        I3CCSR__I3CBase__DCT_SECTION_OFFSET_bit_cg [5-1:0]TABLE_INDEX_bit_cg;
        I3CCSR__I3CBase__DCT_SECTION_OFFSET_bit_cg [4-1:0]ENTRY_SIZE_bit_cg;
        I3CCSR__I3CBase__DCT_SECTION_OFFSET_fld_cg fld_cg;
        rand uvm_reg_field TABLE_OFFSET;
        rand uvm_reg_field TABLE_SIZE;
        rand uvm_reg_field TABLE_INDEX;
        rand uvm_reg_field ENTRY_SIZE;

        function new(string name = "I3CCSR__I3CBase__DCT_SECTION_OFFSET");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TABLE_OFFSET = new("TABLE_OFFSET");
            this.TABLE_OFFSET.configure(this, 12, 0, "RO", 0, 'h800, 1, 1, 0);
            this.TABLE_SIZE = new("TABLE_SIZE");
            this.TABLE_SIZE.configure(this, 7, 12, "RO", 0, 'h7f, 1, 1, 0);
            this.TABLE_INDEX = new("TABLE_INDEX");
            this.TABLE_INDEX.configure(this, 5, 19, "RW", 1, 'h0, 1, 1, 0);
            this.ENTRY_SIZE = new("ENTRY_SIZE");
            this.ENTRY_SIZE.configure(this, 4, 28, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TABLE_OFFSET_bit_cg[bt]) TABLE_OFFSET_bit_cg[bt] = new();
                foreach(TABLE_SIZE_bit_cg[bt]) TABLE_SIZE_bit_cg[bt] = new();
                foreach(TABLE_INDEX_bit_cg[bt]) TABLE_INDEX_bit_cg[bt] = new();
                foreach(ENTRY_SIZE_bit_cg[bt]) ENTRY_SIZE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__DCT_SECTION_OFFSET

    // Reg - I3CCSR.I3CBase.RING_HEADERS_SECTION_OFFSET
    class I3CCSR__I3CBase__RING_HEADERS_SECTION_OFFSET extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__RING_HEADERS_SECTION_OFFSET_bit_cg [16-1:0]SECTION_OFFSET_bit_cg;
        I3CCSR__I3CBase__RING_HEADERS_SECTION_OFFSET_fld_cg fld_cg;
        rand uvm_reg_field SECTION_OFFSET;

        function new(string name = "I3CCSR__I3CBase__RING_HEADERS_SECTION_OFFSET");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.SECTION_OFFSET = new("SECTION_OFFSET");
            this.SECTION_OFFSET.configure(this, 16, 0, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(SECTION_OFFSET_bit_cg[bt]) SECTION_OFFSET_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__RING_HEADERS_SECTION_OFFSET

    // Reg - I3CCSR.I3CBase.PIO_SECTION_OFFSET
    class I3CCSR__I3CBase__PIO_SECTION_OFFSET extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__PIO_SECTION_OFFSET_bit_cg [16-1:0]SECTION_OFFSET_bit_cg;
        I3CCSR__I3CBase__PIO_SECTION_OFFSET_fld_cg fld_cg;
        rand uvm_reg_field SECTION_OFFSET;

        function new(string name = "I3CCSR__I3CBase__PIO_SECTION_OFFSET");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.SECTION_OFFSET = new("SECTION_OFFSET");
            this.SECTION_OFFSET.configure(this, 16, 0, "RO", 0, 'h80, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(SECTION_OFFSET_bit_cg[bt]) SECTION_OFFSET_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__PIO_SECTION_OFFSET

    // Reg - I3CCSR.I3CBase.EXT_CAPS_SECTION_OFFSET
    class I3CCSR__I3CBase__EXT_CAPS_SECTION_OFFSET extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__EXT_CAPS_SECTION_OFFSET_bit_cg [16-1:0]SECTION_OFFSET_bit_cg;
        I3CCSR__I3CBase__EXT_CAPS_SECTION_OFFSET_fld_cg fld_cg;
        rand uvm_reg_field SECTION_OFFSET;

        function new(string name = "I3CCSR__I3CBase__EXT_CAPS_SECTION_OFFSET");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.SECTION_OFFSET = new("SECTION_OFFSET");
            this.SECTION_OFFSET.configure(this, 16, 0, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(SECTION_OFFSET_bit_cg[bt]) SECTION_OFFSET_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__EXT_CAPS_SECTION_OFFSET

    // Reg - I3CCSR.I3CBase.INT_CTRL_CMDS_EN
    class I3CCSR__I3CBase__INT_CTRL_CMDS_EN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__INT_CTRL_CMDS_EN_bit_cg [1-1:0]ICC_SUPPORT_bit_cg;
        I3CCSR__I3CBase__INT_CTRL_CMDS_EN_bit_cg [15-1:0]MIPI_CMDS_SUPPORTED_bit_cg;
        I3CCSR__I3CBase__INT_CTRL_CMDS_EN_fld_cg fld_cg;
        rand uvm_reg_field ICC_SUPPORT;
        rand uvm_reg_field MIPI_CMDS_SUPPORTED;

        function new(string name = "I3CCSR__I3CBase__INT_CTRL_CMDS_EN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ICC_SUPPORT = new("ICC_SUPPORT");
            this.ICC_SUPPORT.configure(this, 1, 0, "RO", 0, 'h1, 1, 1, 0);
            this.MIPI_CMDS_SUPPORTED = new("MIPI_CMDS_SUPPORTED");
            this.MIPI_CMDS_SUPPORTED.configure(this, 15, 1, "RO", 0, 'h35, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ICC_SUPPORT_bit_cg[bt]) ICC_SUPPORT_bit_cg[bt] = new();
                foreach(MIPI_CMDS_SUPPORTED_bit_cg[bt]) MIPI_CMDS_SUPPORTED_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__INT_CTRL_CMDS_EN

    // Reg - I3CCSR.I3CBase.IBI_NOTIFY_CTRL
    class I3CCSR__I3CBase__IBI_NOTIFY_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__IBI_NOTIFY_CTRL_bit_cg [1-1:0]NOTIFY_HJ_REJECTED_bit_cg;
        I3CCSR__I3CBase__IBI_NOTIFY_CTRL_bit_cg [1-1:0]NOTIFY_CRR_REJECTED_bit_cg;
        I3CCSR__I3CBase__IBI_NOTIFY_CTRL_bit_cg [1-1:0]NOTIFY_IBI_REJECTED_bit_cg;
        I3CCSR__I3CBase__IBI_NOTIFY_CTRL_fld_cg fld_cg;
        rand uvm_reg_field NOTIFY_HJ_REJECTED;
        rand uvm_reg_field NOTIFY_CRR_REJECTED;
        rand uvm_reg_field NOTIFY_IBI_REJECTED;

        function new(string name = "I3CCSR__I3CBase__IBI_NOTIFY_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.NOTIFY_HJ_REJECTED = new("NOTIFY_HJ_REJECTED");
            this.NOTIFY_HJ_REJECTED.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.NOTIFY_CRR_REJECTED = new("NOTIFY_CRR_REJECTED");
            this.NOTIFY_CRR_REJECTED.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.NOTIFY_IBI_REJECTED = new("NOTIFY_IBI_REJECTED");
            this.NOTIFY_IBI_REJECTED.configure(this, 1, 3, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(NOTIFY_HJ_REJECTED_bit_cg[bt]) NOTIFY_HJ_REJECTED_bit_cg[bt] = new();
                foreach(NOTIFY_CRR_REJECTED_bit_cg[bt]) NOTIFY_CRR_REJECTED_bit_cg[bt] = new();
                foreach(NOTIFY_IBI_REJECTED_bit_cg[bt]) NOTIFY_IBI_REJECTED_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__IBI_NOTIFY_CTRL

    // Reg - I3CCSR.I3CBase.IBI_DATA_ABORT_CTRL
    class I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL_bit_cg [8-1:0]MATCH_IBI_ID_bit_cg;
        I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL_bit_cg [2-1:0]AFTER_N_CHUNKS_bit_cg;
        I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL_bit_cg [3-1:0]MATCH_STATUS_TYPE_bit_cg;
        I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL_bit_cg [1-1:0]IBI_DATA_ABORT_MON_bit_cg;
        I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL_fld_cg fld_cg;
        rand uvm_reg_field MATCH_IBI_ID;
        rand uvm_reg_field AFTER_N_CHUNKS;
        rand uvm_reg_field MATCH_STATUS_TYPE;
        rand uvm_reg_field IBI_DATA_ABORT_MON;

        function new(string name = "I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.MATCH_IBI_ID = new("MATCH_IBI_ID");
            this.MATCH_IBI_ID.configure(this, 8, 8, "RW", 0, 'h0, 1, 1, 0);
            this.AFTER_N_CHUNKS = new("AFTER_N_CHUNKS");
            this.AFTER_N_CHUNKS.configure(this, 2, 16, "RW", 0, 'h0, 1, 1, 0);
            this.MATCH_STATUS_TYPE = new("MATCH_STATUS_TYPE");
            this.MATCH_STATUS_TYPE.configure(this, 3, 18, "RW", 0, 'h0, 1, 1, 0);
            this.IBI_DATA_ABORT_MON = new("IBI_DATA_ABORT_MON");
            this.IBI_DATA_ABORT_MON.configure(this, 1, 31, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(MATCH_IBI_ID_bit_cg[bt]) MATCH_IBI_ID_bit_cg[bt] = new();
                foreach(AFTER_N_CHUNKS_bit_cg[bt]) AFTER_N_CHUNKS_bit_cg[bt] = new();
                foreach(MATCH_STATUS_TYPE_bit_cg[bt]) MATCH_STATUS_TYPE_bit_cg[bt] = new();
                foreach(IBI_DATA_ABORT_MON_bit_cg[bt]) IBI_DATA_ABORT_MON_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL

    // Reg - I3CCSR.I3CBase.DEV_CTX_BASE_LO
    class I3CCSR__I3CBase__DEV_CTX_BASE_LO extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__DEV_CTX_BASE_LO_bit_cg [1-1:0]BASE_LO_bit_cg;
        I3CCSR__I3CBase__DEV_CTX_BASE_LO_fld_cg fld_cg;
        rand uvm_reg_field BASE_LO;

        function new(string name = "I3CCSR__I3CBase__DEV_CTX_BASE_LO");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.BASE_LO = new("BASE_LO");
            this.BASE_LO.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(BASE_LO_bit_cg[bt]) BASE_LO_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__DEV_CTX_BASE_LO

    // Reg - I3CCSR.I3CBase.DEV_CTX_BASE_HI
    class I3CCSR__I3CBase__DEV_CTX_BASE_HI extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__DEV_CTX_BASE_HI_bit_cg [1-1:0]BASE_HI_bit_cg;
        I3CCSR__I3CBase__DEV_CTX_BASE_HI_fld_cg fld_cg;
        rand uvm_reg_field BASE_HI;

        function new(string name = "I3CCSR__I3CBase__DEV_CTX_BASE_HI");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.BASE_HI = new("BASE_HI");
            this.BASE_HI.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(BASE_HI_bit_cg[bt]) BASE_HI_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__DEV_CTX_BASE_HI

    // Reg - I3CCSR.I3CBase.DEV_CTX_SG
    class I3CCSR__I3CBase__DEV_CTX_SG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3CBase__DEV_CTX_SG_bit_cg [16-1:0]LIST_SIZE_bit_cg;
        I3CCSR__I3CBase__DEV_CTX_SG_bit_cg [1-1:0]BLP_bit_cg;
        I3CCSR__I3CBase__DEV_CTX_SG_fld_cg fld_cg;
        rand uvm_reg_field LIST_SIZE;
        rand uvm_reg_field BLP;

        function new(string name = "I3CCSR__I3CBase__DEV_CTX_SG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.LIST_SIZE = new("LIST_SIZE");
            this.LIST_SIZE.configure(this, 16, 0, "RO", 0, 'h0, 1, 1, 0);
            this.BLP = new("BLP");
            this.BLP.configure(this, 1, 31, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(LIST_SIZE_bit_cg[bt]) LIST_SIZE_bit_cg[bt] = new();
                foreach(BLP_bit_cg[bt]) BLP_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3CBase__DEV_CTX_SG

    // Regfile - I3CCSR.I3CBase
    class I3CCSR__I3CBase extends uvm_reg_block;
        rand I3CCSR__I3CBase__HCI_VERSION HCI_VERSION;
        rand I3CCSR__I3CBase__HC_CONTROL HC_CONTROL;
        rand I3CCSR__I3CBase__CONTROLLER_DEVICE_ADDR CONTROLLER_DEVICE_ADDR;
        rand I3CCSR__I3CBase__HC_CAPABILITIES HC_CAPABILITIES;
        rand I3CCSR__I3CBase__RESET_CONTROL RESET_CONTROL;
        rand I3CCSR__I3CBase__PRESENT_STATE PRESENT_STATE;
        rand I3CCSR__I3CBase__INTR_STATUS INTR_STATUS;
        rand I3CCSR__I3CBase__INTR_STATUS_ENABLE INTR_STATUS_ENABLE;
        rand I3CCSR__I3CBase__INTR_SIGNAL_ENABLE INTR_SIGNAL_ENABLE;
        rand I3CCSR__I3CBase__INTR_FORCE INTR_FORCE;
        rand I3CCSR__I3CBase__DAT_SECTION_OFFSET DAT_SECTION_OFFSET;
        rand I3CCSR__I3CBase__DCT_SECTION_OFFSET DCT_SECTION_OFFSET;
        rand I3CCSR__I3CBase__RING_HEADERS_SECTION_OFFSET RING_HEADERS_SECTION_OFFSET;
        rand I3CCSR__I3CBase__PIO_SECTION_OFFSET PIO_SECTION_OFFSET;
        rand I3CCSR__I3CBase__EXT_CAPS_SECTION_OFFSET EXT_CAPS_SECTION_OFFSET;
        rand I3CCSR__I3CBase__INT_CTRL_CMDS_EN INT_CTRL_CMDS_EN;
        rand I3CCSR__I3CBase__IBI_NOTIFY_CTRL IBI_NOTIFY_CTRL;
        rand I3CCSR__I3CBase__IBI_DATA_ABORT_CTRL IBI_DATA_ABORT_CTRL;
        rand I3CCSR__I3CBase__DEV_CTX_BASE_LO DEV_CTX_BASE_LO;
        rand I3CCSR__I3CBase__DEV_CTX_BASE_HI DEV_CTX_BASE_HI;
        rand I3CCSR__I3CBase__DEV_CTX_SG DEV_CTX_SG;

        function new(string name = "I3CCSR__I3CBase");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.HCI_VERSION = new("HCI_VERSION");
            this.HCI_VERSION.configure(this);

            this.HCI_VERSION.build();
            this.default_map.add_reg(this.HCI_VERSION, 'h0);
            this.HC_CONTROL = new("HC_CONTROL");
            this.HC_CONTROL.configure(this);

            this.HC_CONTROL.build();
            this.default_map.add_reg(this.HC_CONTROL, 'h4);
            this.CONTROLLER_DEVICE_ADDR = new("CONTROLLER_DEVICE_ADDR");
            this.CONTROLLER_DEVICE_ADDR.configure(this);

            this.CONTROLLER_DEVICE_ADDR.build();
            this.default_map.add_reg(this.CONTROLLER_DEVICE_ADDR, 'h8);
            this.HC_CAPABILITIES = new("HC_CAPABILITIES");
            this.HC_CAPABILITIES.configure(this);

            this.HC_CAPABILITIES.build();
            this.default_map.add_reg(this.HC_CAPABILITIES, 'hc);
            this.RESET_CONTROL = new("RESET_CONTROL");
            this.RESET_CONTROL.configure(this);

            this.RESET_CONTROL.build();
            this.default_map.add_reg(this.RESET_CONTROL, 'h10);
            this.PRESENT_STATE = new("PRESENT_STATE");
            this.PRESENT_STATE.configure(this);

            this.PRESENT_STATE.build();
            this.default_map.add_reg(this.PRESENT_STATE, 'h14);
            this.INTR_STATUS = new("INTR_STATUS");
            this.INTR_STATUS.configure(this);

            this.INTR_STATUS.build();
            this.default_map.add_reg(this.INTR_STATUS, 'h20);
            this.INTR_STATUS_ENABLE = new("INTR_STATUS_ENABLE");
            this.INTR_STATUS_ENABLE.configure(this);

            this.INTR_STATUS_ENABLE.build();
            this.default_map.add_reg(this.INTR_STATUS_ENABLE, 'h24);
            this.INTR_SIGNAL_ENABLE = new("INTR_SIGNAL_ENABLE");
            this.INTR_SIGNAL_ENABLE.configure(this);

            this.INTR_SIGNAL_ENABLE.build();
            this.default_map.add_reg(this.INTR_SIGNAL_ENABLE, 'h28);
            this.INTR_FORCE = new("INTR_FORCE");
            this.INTR_FORCE.configure(this);

            this.INTR_FORCE.build();
            this.default_map.add_reg(this.INTR_FORCE, 'h2c);
            this.DAT_SECTION_OFFSET = new("DAT_SECTION_OFFSET");
            this.DAT_SECTION_OFFSET.configure(this);

            this.DAT_SECTION_OFFSET.build();
            this.default_map.add_reg(this.DAT_SECTION_OFFSET, 'h30);
            this.DCT_SECTION_OFFSET = new("DCT_SECTION_OFFSET");
            this.DCT_SECTION_OFFSET.configure(this);

            this.DCT_SECTION_OFFSET.build();
            this.default_map.add_reg(this.DCT_SECTION_OFFSET, 'h34);
            this.RING_HEADERS_SECTION_OFFSET = new("RING_HEADERS_SECTION_OFFSET");
            this.RING_HEADERS_SECTION_OFFSET.configure(this);

            this.RING_HEADERS_SECTION_OFFSET.build();
            this.default_map.add_reg(this.RING_HEADERS_SECTION_OFFSET, 'h38);
            this.PIO_SECTION_OFFSET = new("PIO_SECTION_OFFSET");
            this.PIO_SECTION_OFFSET.configure(this);

            this.PIO_SECTION_OFFSET.build();
            this.default_map.add_reg(this.PIO_SECTION_OFFSET, 'h3c);
            this.EXT_CAPS_SECTION_OFFSET = new("EXT_CAPS_SECTION_OFFSET");
            this.EXT_CAPS_SECTION_OFFSET.configure(this);

            this.EXT_CAPS_SECTION_OFFSET.build();
            this.default_map.add_reg(this.EXT_CAPS_SECTION_OFFSET, 'h40);
            this.INT_CTRL_CMDS_EN = new("INT_CTRL_CMDS_EN");
            this.INT_CTRL_CMDS_EN.configure(this);

            this.INT_CTRL_CMDS_EN.build();
            this.default_map.add_reg(this.INT_CTRL_CMDS_EN, 'h4c);
            this.IBI_NOTIFY_CTRL = new("IBI_NOTIFY_CTRL");
            this.IBI_NOTIFY_CTRL.configure(this);

            this.IBI_NOTIFY_CTRL.build();
            this.default_map.add_reg(this.IBI_NOTIFY_CTRL, 'h58);
            this.IBI_DATA_ABORT_CTRL = new("IBI_DATA_ABORT_CTRL");
            this.IBI_DATA_ABORT_CTRL.configure(this);

            this.IBI_DATA_ABORT_CTRL.build();
            this.default_map.add_reg(this.IBI_DATA_ABORT_CTRL, 'h5c);
            this.DEV_CTX_BASE_LO = new("DEV_CTX_BASE_LO");
            this.DEV_CTX_BASE_LO.configure(this);

            this.DEV_CTX_BASE_LO.build();
            this.default_map.add_reg(this.DEV_CTX_BASE_LO, 'h60);
            this.DEV_CTX_BASE_HI = new("DEV_CTX_BASE_HI");
            this.DEV_CTX_BASE_HI.configure(this);

            this.DEV_CTX_BASE_HI.build();
            this.default_map.add_reg(this.DEV_CTX_BASE_HI, 'h64);
            this.DEV_CTX_SG = new("DEV_CTX_SG");
            this.DEV_CTX_SG.configure(this);

            this.DEV_CTX_SG.build();
            this.default_map.add_reg(this.DEV_CTX_SG, 'h68);
        endfunction : build
    endclass : I3CCSR__I3CBase

    // Reg - I3CCSR.PIOControl.COMMAND_PORT
    class I3CCSR__PIOControl__COMMAND_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__COMMAND_PORT_bit_cg [32-1:0]COMMAND_DATA_bit_cg;
        I3CCSR__PIOControl__COMMAND_PORT_fld_cg fld_cg;
        rand uvm_reg_field COMMAND_DATA;

        function new(string name = "I3CCSR__PIOControl__COMMAND_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.COMMAND_DATA = new("COMMAND_DATA");
            this.COMMAND_DATA.configure(this, 32, 0, "WO", 0, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(COMMAND_DATA_bit_cg[bt]) COMMAND_DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__COMMAND_PORT

    // Reg - I3CCSR.PIOControl.RESPONSE_PORT
    class I3CCSR__PIOControl__RESPONSE_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__RESPONSE_PORT_bit_cg [32-1:0]RESPONSE_DATA_bit_cg;
        I3CCSR__PIOControl__RESPONSE_PORT_fld_cg fld_cg;
        rand uvm_reg_field RESPONSE_DATA;

        function new(string name = "I3CCSR__PIOControl__RESPONSE_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RESPONSE_DATA = new("RESPONSE_DATA");
            this.RESPONSE_DATA.configure(this, 32, 0, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RESPONSE_DATA_bit_cg[bt]) RESPONSE_DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__RESPONSE_PORT

    // Reg - I3CCSR.PIOControl.XFER_DATA_PORT
    class I3CCSR__PIOControl__XFER_DATA_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__XFER_DATA_PORT_bit_cg [32-1:0]TX_DATA_bit_cg;
        I3CCSR__PIOControl__XFER_DATA_PORT_bit_cg [32-1:0]RX_DATA_bit_cg;
        I3CCSR__PIOControl__XFER_DATA_PORT_fld_cg fld_cg;
        rand uvm_reg_field TX_DATA;
        rand uvm_reg_field RX_DATA;

        function new(string name = "I3CCSR__PIOControl__XFER_DATA_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_DATA = new("TX_DATA");
            this.TX_DATA.configure(this, 32, 0, "WO", 0, 'h0, 0, 1, 0);
            this.RX_DATA = new("RX_DATA");
            this.RX_DATA.configure(this, 32, 0, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_DATA_bit_cg[bt]) TX_DATA_bit_cg[bt] = new();
                foreach(RX_DATA_bit_cg[bt]) RX_DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__XFER_DATA_PORT

    // Reg - I3CCSR.PIOControl.IBI_PORT
    class I3CCSR__PIOControl__IBI_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__IBI_PORT_bit_cg [1-1:0]IBI_DATA_bit_cg;
        I3CCSR__PIOControl__IBI_PORT_fld_cg fld_cg;
        rand uvm_reg_field IBI_DATA;

        function new(string name = "I3CCSR__PIOControl__IBI_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.IBI_DATA = new("IBI_DATA");
            this.IBI_DATA.configure(this, 1, 0, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(IBI_DATA_bit_cg[bt]) IBI_DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__IBI_PORT

    // Reg - I3CCSR.PIOControl.QUEUE_THLD_CTRL
    class I3CCSR__PIOControl__QUEUE_THLD_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__QUEUE_THLD_CTRL_bit_cg [8-1:0]CMD_EMPTY_BUF_THLD_bit_cg;
        I3CCSR__PIOControl__QUEUE_THLD_CTRL_bit_cg [8-1:0]RESP_BUF_THLD_bit_cg;
        I3CCSR__PIOControl__QUEUE_THLD_CTRL_bit_cg [8-1:0]IBI_DATA_SEGMENT_SIZE_bit_cg;
        I3CCSR__PIOControl__QUEUE_THLD_CTRL_bit_cg [8-1:0]IBI_STATUS_THLD_bit_cg;
        I3CCSR__PIOControl__QUEUE_THLD_CTRL_fld_cg fld_cg;
        rand uvm_reg_field CMD_EMPTY_BUF_THLD;
        rand uvm_reg_field RESP_BUF_THLD;
        rand uvm_reg_field IBI_DATA_SEGMENT_SIZE;
        rand uvm_reg_field IBI_STATUS_THLD;

        function new(string name = "I3CCSR__PIOControl__QUEUE_THLD_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CMD_EMPTY_BUF_THLD = new("CMD_EMPTY_BUF_THLD");
            this.CMD_EMPTY_BUF_THLD.configure(this, 8, 0, "RW", 0, 'h1, 1, 1, 0);
            this.RESP_BUF_THLD = new("RESP_BUF_THLD");
            this.RESP_BUF_THLD.configure(this, 8, 8, "RW", 0, 'h1, 1, 1, 0);
            this.IBI_DATA_SEGMENT_SIZE = new("IBI_DATA_SEGMENT_SIZE");
            this.IBI_DATA_SEGMENT_SIZE.configure(this, 8, 16, "RW", 0, 'h1, 1, 1, 0);
            this.IBI_STATUS_THLD = new("IBI_STATUS_THLD");
            this.IBI_STATUS_THLD.configure(this, 8, 24, "RW", 0, 'h1, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CMD_EMPTY_BUF_THLD_bit_cg[bt]) CMD_EMPTY_BUF_THLD_bit_cg[bt] = new();
                foreach(RESP_BUF_THLD_bit_cg[bt]) RESP_BUF_THLD_bit_cg[bt] = new();
                foreach(IBI_DATA_SEGMENT_SIZE_bit_cg[bt]) IBI_DATA_SEGMENT_SIZE_bit_cg[bt] = new();
                foreach(IBI_STATUS_THLD_bit_cg[bt]) IBI_STATUS_THLD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__QUEUE_THLD_CTRL

    // Reg - I3CCSR.PIOControl.DATA_BUFFER_THLD_CTRL
    class I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL_bit_cg [3-1:0]TX_BUF_THLD_bit_cg;
        I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL_bit_cg [3-1:0]RX_BUF_THLD_bit_cg;
        I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL_bit_cg [3-1:0]TX_START_THLD_bit_cg;
        I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL_bit_cg [3-1:0]RX_START_THLD_bit_cg;
        I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL_fld_cg fld_cg;
        rand uvm_reg_field TX_BUF_THLD;
        rand uvm_reg_field RX_BUF_THLD;
        rand uvm_reg_field TX_START_THLD;
        rand uvm_reg_field RX_START_THLD;

        function new(string name = "I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_BUF_THLD = new("TX_BUF_THLD");
            this.TX_BUF_THLD.configure(this, 3, 0, "RW", 0, 'h1, 1, 1, 0);
            this.RX_BUF_THLD = new("RX_BUF_THLD");
            this.RX_BUF_THLD.configure(this, 3, 8, "RW", 0, 'h1, 1, 1, 0);
            this.TX_START_THLD = new("TX_START_THLD");
            this.TX_START_THLD.configure(this, 3, 16, "RW", 0, 'h1, 1, 1, 0);
            this.RX_START_THLD = new("RX_START_THLD");
            this.RX_START_THLD.configure(this, 3, 24, "RW", 0, 'h1, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_BUF_THLD_bit_cg[bt]) TX_BUF_THLD_bit_cg[bt] = new();
                foreach(RX_BUF_THLD_bit_cg[bt]) RX_BUF_THLD_bit_cg[bt] = new();
                foreach(TX_START_THLD_bit_cg[bt]) TX_START_THLD_bit_cg[bt] = new();
                foreach(RX_START_THLD_bit_cg[bt]) RX_START_THLD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL

    // Reg - I3CCSR.PIOControl.QUEUE_SIZE
    class I3CCSR__PIOControl__QUEUE_SIZE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__QUEUE_SIZE_bit_cg [8-1:0]CR_QUEUE_SIZE_bit_cg;
        I3CCSR__PIOControl__QUEUE_SIZE_bit_cg [8-1:0]IBI_STATUS_SIZE_bit_cg;
        I3CCSR__PIOControl__QUEUE_SIZE_bit_cg [8-1:0]RX_DATA_BUFFER_SIZE_bit_cg;
        I3CCSR__PIOControl__QUEUE_SIZE_bit_cg [8-1:0]TX_DATA_BUFFER_SIZE_bit_cg;
        I3CCSR__PIOControl__QUEUE_SIZE_fld_cg fld_cg;
        rand uvm_reg_field CR_QUEUE_SIZE;
        rand uvm_reg_field IBI_STATUS_SIZE;
        rand uvm_reg_field RX_DATA_BUFFER_SIZE;
        rand uvm_reg_field TX_DATA_BUFFER_SIZE;

        function new(string name = "I3CCSR__PIOControl__QUEUE_SIZE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CR_QUEUE_SIZE = new("CR_QUEUE_SIZE");
            this.CR_QUEUE_SIZE.configure(this, 8, 0, "RO", 0, 'h40, 1, 1, 0);
            this.IBI_STATUS_SIZE = new("IBI_STATUS_SIZE");
            this.IBI_STATUS_SIZE.configure(this, 8, 8, "RO", 0, 'h40, 1, 1, 0);
            this.RX_DATA_BUFFER_SIZE = new("RX_DATA_BUFFER_SIZE");
            this.RX_DATA_BUFFER_SIZE.configure(this, 8, 16, "RO", 0, 'h5, 1, 1, 0);
            this.TX_DATA_BUFFER_SIZE = new("TX_DATA_BUFFER_SIZE");
            this.TX_DATA_BUFFER_SIZE.configure(this, 8, 24, "RO", 0, 'h5, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CR_QUEUE_SIZE_bit_cg[bt]) CR_QUEUE_SIZE_bit_cg[bt] = new();
                foreach(IBI_STATUS_SIZE_bit_cg[bt]) IBI_STATUS_SIZE_bit_cg[bt] = new();
                foreach(RX_DATA_BUFFER_SIZE_bit_cg[bt]) RX_DATA_BUFFER_SIZE_bit_cg[bt] = new();
                foreach(TX_DATA_BUFFER_SIZE_bit_cg[bt]) TX_DATA_BUFFER_SIZE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__QUEUE_SIZE

    // Reg - I3CCSR.PIOControl.ALT_QUEUE_SIZE
    class I3CCSR__PIOControl__ALT_QUEUE_SIZE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__ALT_QUEUE_SIZE_bit_cg [8-1:0]ALT_RESP_QUEUE_SIZE_bit_cg;
        I3CCSR__PIOControl__ALT_QUEUE_SIZE_bit_cg [1-1:0]ALT_RESP_QUEUE_EN_bit_cg;
        I3CCSR__PIOControl__ALT_QUEUE_SIZE_bit_cg [1-1:0]EXT_IBI_QUEUE_EN_bit_cg;
        I3CCSR__PIOControl__ALT_QUEUE_SIZE_fld_cg fld_cg;
        rand uvm_reg_field ALT_RESP_QUEUE_SIZE;
        rand uvm_reg_field ALT_RESP_QUEUE_EN;
        rand uvm_reg_field EXT_IBI_QUEUE_EN;

        function new(string name = "I3CCSR__PIOControl__ALT_QUEUE_SIZE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ALT_RESP_QUEUE_SIZE = new("ALT_RESP_QUEUE_SIZE");
            this.ALT_RESP_QUEUE_SIZE.configure(this, 8, 0, "RO", 0, 'h40, 1, 1, 0);
            this.ALT_RESP_QUEUE_EN = new("ALT_RESP_QUEUE_EN");
            this.ALT_RESP_QUEUE_EN.configure(this, 1, 24, "RO", 0, 'h0, 1, 1, 0);
            this.EXT_IBI_QUEUE_EN = new("EXT_IBI_QUEUE_EN");
            this.EXT_IBI_QUEUE_EN.configure(this, 1, 28, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ALT_RESP_QUEUE_SIZE_bit_cg[bt]) ALT_RESP_QUEUE_SIZE_bit_cg[bt] = new();
                foreach(ALT_RESP_QUEUE_EN_bit_cg[bt]) ALT_RESP_QUEUE_EN_bit_cg[bt] = new();
                foreach(EXT_IBI_QUEUE_EN_bit_cg[bt]) EXT_IBI_QUEUE_EN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__ALT_QUEUE_SIZE

    // Reg - I3CCSR.PIOControl.PIO_INTR_STATUS
    class I3CCSR__PIOControl__PIO_INTR_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__PIO_INTR_STATUS_bit_cg [1-1:0]TX_THLD_STAT_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_bit_cg [1-1:0]RX_THLD_STAT_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_bit_cg [1-1:0]IBI_STATUS_THLD_STAT_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_bit_cg [1-1:0]CMD_QUEUE_READY_STAT_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_bit_cg [1-1:0]RESP_READY_STAT_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_bit_cg [1-1:0]TRANSFER_ABORT_STAT_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_bit_cg [1-1:0]TRANSFER_ERR_STAT_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_fld_cg fld_cg;
        rand uvm_reg_field TX_THLD_STAT;
        rand uvm_reg_field RX_THLD_STAT;
        rand uvm_reg_field IBI_STATUS_THLD_STAT;
        rand uvm_reg_field CMD_QUEUE_READY_STAT;
        rand uvm_reg_field RESP_READY_STAT;
        rand uvm_reg_field TRANSFER_ABORT_STAT;
        rand uvm_reg_field TRANSFER_ERR_STAT;

        function new(string name = "I3CCSR__PIOControl__PIO_INTR_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_THLD_STAT = new("TX_THLD_STAT");
            this.TX_THLD_STAT.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            this.RX_THLD_STAT = new("RX_THLD_STAT");
            this.RX_THLD_STAT.configure(this, 1, 1, "RO", 1, 'h0, 1, 1, 0);
            this.IBI_STATUS_THLD_STAT = new("IBI_STATUS_THLD_STAT");
            this.IBI_STATUS_THLD_STAT.configure(this, 1, 2, "RO", 1, 'h0, 1, 1, 0);
            this.CMD_QUEUE_READY_STAT = new("CMD_QUEUE_READY_STAT");
            this.CMD_QUEUE_READY_STAT.configure(this, 1, 3, "RO", 1, 'h0, 1, 1, 0);
            this.RESP_READY_STAT = new("RESP_READY_STAT");
            this.RESP_READY_STAT.configure(this, 1, 4, "RO", 1, 'h0, 1, 1, 0);
            this.TRANSFER_ABORT_STAT = new("TRANSFER_ABORT_STAT");
            this.TRANSFER_ABORT_STAT.configure(this, 1, 5, "W1C", 1, 'h0, 1, 1, 0);
            this.TRANSFER_ERR_STAT = new("TRANSFER_ERR_STAT");
            this.TRANSFER_ERR_STAT.configure(this, 1, 9, "W1C", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_THLD_STAT_bit_cg[bt]) TX_THLD_STAT_bit_cg[bt] = new();
                foreach(RX_THLD_STAT_bit_cg[bt]) RX_THLD_STAT_bit_cg[bt] = new();
                foreach(IBI_STATUS_THLD_STAT_bit_cg[bt]) IBI_STATUS_THLD_STAT_bit_cg[bt] = new();
                foreach(CMD_QUEUE_READY_STAT_bit_cg[bt]) CMD_QUEUE_READY_STAT_bit_cg[bt] = new();
                foreach(RESP_READY_STAT_bit_cg[bt]) RESP_READY_STAT_bit_cg[bt] = new();
                foreach(TRANSFER_ABORT_STAT_bit_cg[bt]) TRANSFER_ABORT_STAT_bit_cg[bt] = new();
                foreach(TRANSFER_ERR_STAT_bit_cg[bt]) TRANSFER_ERR_STAT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__PIO_INTR_STATUS

    // Reg - I3CCSR.PIOControl.PIO_INTR_STATUS_ENABLE
    class I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_bit_cg [1-1:0]TX_THLD_STAT_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_bit_cg [1-1:0]RX_THLD_STAT_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_bit_cg [1-1:0]IBI_STATUS_THLD_STAT_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_bit_cg [1-1:0]CMD_QUEUE_READY_STAT_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_bit_cg [1-1:0]RESP_READY_STAT_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_bit_cg [1-1:0]TRANSFER_ABORT_STAT_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_bit_cg [1-1:0]TRANSFER_ERR_STAT_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE_fld_cg fld_cg;
        rand uvm_reg_field TX_THLD_STAT_EN;
        rand uvm_reg_field RX_THLD_STAT_EN;
        rand uvm_reg_field IBI_STATUS_THLD_STAT_EN;
        rand uvm_reg_field CMD_QUEUE_READY_STAT_EN;
        rand uvm_reg_field RESP_READY_STAT_EN;
        rand uvm_reg_field TRANSFER_ABORT_STAT_EN;
        rand uvm_reg_field TRANSFER_ERR_STAT_EN;

        function new(string name = "I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_THLD_STAT_EN = new("TX_THLD_STAT_EN");
            this.TX_THLD_STAT_EN.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.RX_THLD_STAT_EN = new("RX_THLD_STAT_EN");
            this.RX_THLD_STAT_EN.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.IBI_STATUS_THLD_STAT_EN = new("IBI_STATUS_THLD_STAT_EN");
            this.IBI_STATUS_THLD_STAT_EN.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            this.CMD_QUEUE_READY_STAT_EN = new("CMD_QUEUE_READY_STAT_EN");
            this.CMD_QUEUE_READY_STAT_EN.configure(this, 1, 3, "RW", 0, 'h0, 1, 1, 0);
            this.RESP_READY_STAT_EN = new("RESP_READY_STAT_EN");
            this.RESP_READY_STAT_EN.configure(this, 1, 4, "RW", 0, 'h0, 1, 1, 0);
            this.TRANSFER_ABORT_STAT_EN = new("TRANSFER_ABORT_STAT_EN");
            this.TRANSFER_ABORT_STAT_EN.configure(this, 1, 5, "RW", 0, 'h0, 1, 1, 0);
            this.TRANSFER_ERR_STAT_EN = new("TRANSFER_ERR_STAT_EN");
            this.TRANSFER_ERR_STAT_EN.configure(this, 1, 9, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_THLD_STAT_EN_bit_cg[bt]) TX_THLD_STAT_EN_bit_cg[bt] = new();
                foreach(RX_THLD_STAT_EN_bit_cg[bt]) RX_THLD_STAT_EN_bit_cg[bt] = new();
                foreach(IBI_STATUS_THLD_STAT_EN_bit_cg[bt]) IBI_STATUS_THLD_STAT_EN_bit_cg[bt] = new();
                foreach(CMD_QUEUE_READY_STAT_EN_bit_cg[bt]) CMD_QUEUE_READY_STAT_EN_bit_cg[bt] = new();
                foreach(RESP_READY_STAT_EN_bit_cg[bt]) RESP_READY_STAT_EN_bit_cg[bt] = new();
                foreach(TRANSFER_ABORT_STAT_EN_bit_cg[bt]) TRANSFER_ABORT_STAT_EN_bit_cg[bt] = new();
                foreach(TRANSFER_ERR_STAT_EN_bit_cg[bt]) TRANSFER_ERR_STAT_EN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE

    // Reg - I3CCSR.PIOControl.PIO_INTR_SIGNAL_ENABLE
    class I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]TX_THLD_SIGNAL_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]RX_THLD_SIGNAL_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]IBI_STATUS_THLD_SIGNAL_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]CMD_QUEUE_READY_SIGNAL_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]RESP_READY_SIGNAL_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]TRANSFER_ABORT_SIGNAL_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]TRANSFER_ERR_SIGNAL_EN_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE_fld_cg fld_cg;
        rand uvm_reg_field TX_THLD_SIGNAL_EN;
        rand uvm_reg_field RX_THLD_SIGNAL_EN;
        rand uvm_reg_field IBI_STATUS_THLD_SIGNAL_EN;
        rand uvm_reg_field CMD_QUEUE_READY_SIGNAL_EN;
        rand uvm_reg_field RESP_READY_SIGNAL_EN;
        rand uvm_reg_field TRANSFER_ABORT_SIGNAL_EN;
        rand uvm_reg_field TRANSFER_ERR_SIGNAL_EN;

        function new(string name = "I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_THLD_SIGNAL_EN = new("TX_THLD_SIGNAL_EN");
            this.TX_THLD_SIGNAL_EN.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.RX_THLD_SIGNAL_EN = new("RX_THLD_SIGNAL_EN");
            this.RX_THLD_SIGNAL_EN.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.IBI_STATUS_THLD_SIGNAL_EN = new("IBI_STATUS_THLD_SIGNAL_EN");
            this.IBI_STATUS_THLD_SIGNAL_EN.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            this.CMD_QUEUE_READY_SIGNAL_EN = new("CMD_QUEUE_READY_SIGNAL_EN");
            this.CMD_QUEUE_READY_SIGNAL_EN.configure(this, 1, 3, "RW", 0, 'h0, 1, 1, 0);
            this.RESP_READY_SIGNAL_EN = new("RESP_READY_SIGNAL_EN");
            this.RESP_READY_SIGNAL_EN.configure(this, 1, 4, "RW", 0, 'h0, 1, 1, 0);
            this.TRANSFER_ABORT_SIGNAL_EN = new("TRANSFER_ABORT_SIGNAL_EN");
            this.TRANSFER_ABORT_SIGNAL_EN.configure(this, 1, 5, "RW", 0, 'h0, 1, 1, 0);
            this.TRANSFER_ERR_SIGNAL_EN = new("TRANSFER_ERR_SIGNAL_EN");
            this.TRANSFER_ERR_SIGNAL_EN.configure(this, 1, 9, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_THLD_SIGNAL_EN_bit_cg[bt]) TX_THLD_SIGNAL_EN_bit_cg[bt] = new();
                foreach(RX_THLD_SIGNAL_EN_bit_cg[bt]) RX_THLD_SIGNAL_EN_bit_cg[bt] = new();
                foreach(IBI_STATUS_THLD_SIGNAL_EN_bit_cg[bt]) IBI_STATUS_THLD_SIGNAL_EN_bit_cg[bt] = new();
                foreach(CMD_QUEUE_READY_SIGNAL_EN_bit_cg[bt]) CMD_QUEUE_READY_SIGNAL_EN_bit_cg[bt] = new();
                foreach(RESP_READY_SIGNAL_EN_bit_cg[bt]) RESP_READY_SIGNAL_EN_bit_cg[bt] = new();
                foreach(TRANSFER_ABORT_SIGNAL_EN_bit_cg[bt]) TRANSFER_ABORT_SIGNAL_EN_bit_cg[bt] = new();
                foreach(TRANSFER_ERR_SIGNAL_EN_bit_cg[bt]) TRANSFER_ERR_SIGNAL_EN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE

    // Reg - I3CCSR.PIOControl.PIO_INTR_FORCE
    class I3CCSR__PIOControl__PIO_INTR_FORCE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__PIO_INTR_FORCE_bit_cg [1-1:0]TX_THLD_FORCE_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_FORCE_bit_cg [1-1:0]RX_THLD_FORCE_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_FORCE_bit_cg [1-1:0]IBI_THLD_FORCE_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_FORCE_bit_cg [1-1:0]CMD_QUEUE_READY_FORCE_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_FORCE_bit_cg [1-1:0]RESP_READY_FORCE_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_FORCE_bit_cg [1-1:0]TRANSFER_ABORT_FORCE_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_FORCE_bit_cg [1-1:0]TRANSFER_ERR_FORCE_bit_cg;
        I3CCSR__PIOControl__PIO_INTR_FORCE_fld_cg fld_cg;
        rand uvm_reg_field TX_THLD_FORCE;
        rand uvm_reg_field RX_THLD_FORCE;
        rand uvm_reg_field IBI_THLD_FORCE;
        rand uvm_reg_field CMD_QUEUE_READY_FORCE;
        rand uvm_reg_field RESP_READY_FORCE;
        rand uvm_reg_field TRANSFER_ABORT_FORCE;
        rand uvm_reg_field TRANSFER_ERR_FORCE;

        function new(string name = "I3CCSR__PIOControl__PIO_INTR_FORCE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_THLD_FORCE = new("TX_THLD_FORCE");
            this.TX_THLD_FORCE.configure(this, 1, 0, "WO", 0, 'h0, 1, 1, 0);
            this.RX_THLD_FORCE = new("RX_THLD_FORCE");
            this.RX_THLD_FORCE.configure(this, 1, 1, "WO", 0, 'h0, 1, 1, 0);
            this.IBI_THLD_FORCE = new("IBI_THLD_FORCE");
            this.IBI_THLD_FORCE.configure(this, 1, 2, "WO", 0, 'h0, 1, 1, 0);
            this.CMD_QUEUE_READY_FORCE = new("CMD_QUEUE_READY_FORCE");
            this.CMD_QUEUE_READY_FORCE.configure(this, 1, 3, "WO", 0, 'h0, 1, 1, 0);
            this.RESP_READY_FORCE = new("RESP_READY_FORCE");
            this.RESP_READY_FORCE.configure(this, 1, 4, "WO", 0, 'h0, 1, 1, 0);
            this.TRANSFER_ABORT_FORCE = new("TRANSFER_ABORT_FORCE");
            this.TRANSFER_ABORT_FORCE.configure(this, 1, 5, "WO", 0, 'h0, 1, 1, 0);
            this.TRANSFER_ERR_FORCE = new("TRANSFER_ERR_FORCE");
            this.TRANSFER_ERR_FORCE.configure(this, 1, 9, "WO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_THLD_FORCE_bit_cg[bt]) TX_THLD_FORCE_bit_cg[bt] = new();
                foreach(RX_THLD_FORCE_bit_cg[bt]) RX_THLD_FORCE_bit_cg[bt] = new();
                foreach(IBI_THLD_FORCE_bit_cg[bt]) IBI_THLD_FORCE_bit_cg[bt] = new();
                foreach(CMD_QUEUE_READY_FORCE_bit_cg[bt]) CMD_QUEUE_READY_FORCE_bit_cg[bt] = new();
                foreach(RESP_READY_FORCE_bit_cg[bt]) RESP_READY_FORCE_bit_cg[bt] = new();
                foreach(TRANSFER_ABORT_FORCE_bit_cg[bt]) TRANSFER_ABORT_FORCE_bit_cg[bt] = new();
                foreach(TRANSFER_ERR_FORCE_bit_cg[bt]) TRANSFER_ERR_FORCE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__PIO_INTR_FORCE

    // Reg - I3CCSR.PIOControl.PIO_CONTROL
    class I3CCSR__PIOControl__PIO_CONTROL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__PIOControl__PIO_CONTROL_bit_cg [1-1:0]ENABLE_bit_cg;
        I3CCSR__PIOControl__PIO_CONTROL_bit_cg [1-1:0]RS_bit_cg;
        I3CCSR__PIOControl__PIO_CONTROL_bit_cg [1-1:0]ABORT_bit_cg;
        I3CCSR__PIOControl__PIO_CONTROL_fld_cg fld_cg;
        rand uvm_reg_field ENABLE;
        rand uvm_reg_field RS;
        rand uvm_reg_field ABORT;

        function new(string name = "I3CCSR__PIOControl__PIO_CONTROL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ENABLE = new("ENABLE");
            this.ENABLE.configure(this, 1, 0, "RW", 0, 'h1, 1, 1, 0);
            this.RS = new("RS");
            this.RS.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.ABORT = new("ABORT");
            this.ABORT.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ENABLE_bit_cg[bt]) ENABLE_bit_cg[bt] = new();
                foreach(RS_bit_cg[bt]) RS_bit_cg[bt] = new();
                foreach(ABORT_bit_cg[bt]) ABORT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__PIOControl__PIO_CONTROL

    // Regfile - I3CCSR.PIOControl
    class I3CCSR__PIOControl extends uvm_reg_block;
        rand I3CCSR__PIOControl__COMMAND_PORT COMMAND_PORT;
        rand I3CCSR__PIOControl__RESPONSE_PORT RESPONSE_PORT;
        rand I3CCSR__PIOControl__XFER_DATA_PORT XFER_DATA_PORT;
        rand I3CCSR__PIOControl__IBI_PORT IBI_PORT;
        rand I3CCSR__PIOControl__QUEUE_THLD_CTRL QUEUE_THLD_CTRL;
        rand I3CCSR__PIOControl__DATA_BUFFER_THLD_CTRL DATA_BUFFER_THLD_CTRL;
        rand I3CCSR__PIOControl__QUEUE_SIZE QUEUE_SIZE;
        rand I3CCSR__PIOControl__ALT_QUEUE_SIZE ALT_QUEUE_SIZE;
        rand I3CCSR__PIOControl__PIO_INTR_STATUS PIO_INTR_STATUS;
        rand I3CCSR__PIOControl__PIO_INTR_STATUS_ENABLE PIO_INTR_STATUS_ENABLE;
        rand I3CCSR__PIOControl__PIO_INTR_SIGNAL_ENABLE PIO_INTR_SIGNAL_ENABLE;
        rand I3CCSR__PIOControl__PIO_INTR_FORCE PIO_INTR_FORCE;
        rand I3CCSR__PIOControl__PIO_CONTROL PIO_CONTROL;

        function new(string name = "I3CCSR__PIOControl");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.COMMAND_PORT = new("COMMAND_PORT");
            this.COMMAND_PORT.configure(this);

            this.COMMAND_PORT.build();
            this.default_map.add_reg(this.COMMAND_PORT, 'h0);
            this.RESPONSE_PORT = new("RESPONSE_PORT");
            this.RESPONSE_PORT.configure(this);

            this.RESPONSE_PORT.build();
            this.default_map.add_reg(this.RESPONSE_PORT, 'h4);
            this.XFER_DATA_PORT = new("XFER_DATA_PORT");
            this.XFER_DATA_PORT.configure(this);

            this.XFER_DATA_PORT.build();
            this.default_map.add_reg(this.XFER_DATA_PORT, 'h8);
            this.IBI_PORT = new("IBI_PORT");
            this.IBI_PORT.configure(this);

            this.IBI_PORT.build();
            this.default_map.add_reg(this.IBI_PORT, 'hc);
            this.QUEUE_THLD_CTRL = new("QUEUE_THLD_CTRL");
            this.QUEUE_THLD_CTRL.configure(this);

            this.QUEUE_THLD_CTRL.build();
            this.default_map.add_reg(this.QUEUE_THLD_CTRL, 'h10);
            this.DATA_BUFFER_THLD_CTRL = new("DATA_BUFFER_THLD_CTRL");
            this.DATA_BUFFER_THLD_CTRL.configure(this);

            this.DATA_BUFFER_THLD_CTRL.build();
            this.default_map.add_reg(this.DATA_BUFFER_THLD_CTRL, 'h14);
            this.QUEUE_SIZE = new("QUEUE_SIZE");
            this.QUEUE_SIZE.configure(this);

            this.QUEUE_SIZE.build();
            this.default_map.add_reg(this.QUEUE_SIZE, 'h18);
            this.ALT_QUEUE_SIZE = new("ALT_QUEUE_SIZE");
            this.ALT_QUEUE_SIZE.configure(this);

            this.ALT_QUEUE_SIZE.build();
            this.default_map.add_reg(this.ALT_QUEUE_SIZE, 'h1c);
            this.PIO_INTR_STATUS = new("PIO_INTR_STATUS");
            this.PIO_INTR_STATUS.configure(this);

            this.PIO_INTR_STATUS.build();
            this.default_map.add_reg(this.PIO_INTR_STATUS, 'h20);
            this.PIO_INTR_STATUS_ENABLE = new("PIO_INTR_STATUS_ENABLE");
            this.PIO_INTR_STATUS_ENABLE.configure(this);

            this.PIO_INTR_STATUS_ENABLE.build();
            this.default_map.add_reg(this.PIO_INTR_STATUS_ENABLE, 'h24);
            this.PIO_INTR_SIGNAL_ENABLE = new("PIO_INTR_SIGNAL_ENABLE");
            this.PIO_INTR_SIGNAL_ENABLE.configure(this);

            this.PIO_INTR_SIGNAL_ENABLE.build();
            this.default_map.add_reg(this.PIO_INTR_SIGNAL_ENABLE, 'h28);
            this.PIO_INTR_FORCE = new("PIO_INTR_FORCE");
            this.PIO_INTR_FORCE.configure(this);

            this.PIO_INTR_FORCE.build();
            this.default_map.add_reg(this.PIO_INTR_FORCE, 'h2c);
            this.PIO_CONTROL = new("PIO_CONTROL");
            this.PIO_CONTROL.configure(this);

            this.PIO_CONTROL.build();
            this.default_map.add_reg(this.PIO_CONTROL, 'h30);
        endfunction : build
    endclass : I3CCSR__PIOControl

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.EXTCAP_HEADER
    class I3CCSR__I3C_EC__SecFwRecoveryIf__EXTCAP_HEADER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__EXTCAP_HEADER_bit_cg [8-1:0]CAP_ID_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__EXTCAP_HEADER_bit_cg [16-1:0]CAP_LENGTH_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__EXTCAP_HEADER_fld_cg fld_cg;
        rand uvm_reg_field CAP_ID;
        rand uvm_reg_field CAP_LENGTH;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__EXTCAP_HEADER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CAP_ID = new("CAP_ID");
            this.CAP_ID.configure(this, 8, 0, "RO", 0, 'hc0, 1, 1, 0);
            this.CAP_LENGTH = new("CAP_LENGTH");
            this.CAP_LENGTH.configure(this, 16, 8, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CAP_ID_bit_cg[bt]) CAP_ID_bit_cg[bt] = new();
                foreach(CAP_LENGTH_bit_cg[bt]) CAP_LENGTH_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__EXTCAP_HEADER

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.PROT_CAP_0
    class I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_0_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_0_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_0

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.PROT_CAP_1
    class I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_1_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_1_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_1

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.PROT_CAP_2
    class I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_2 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_2_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_2_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_2");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_2

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.PROT_CAP_3
    class I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_3 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_3_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_3_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_3");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_3

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_ID_0
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_0_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_0_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_0

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_ID_1
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_1_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_1_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_1

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_ID_2
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_2 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_2_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_2_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_2");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_2

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_ID_3
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_3 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_3_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_3_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_3");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_3

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_ID_4
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_4 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_4_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_4_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_4");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_4

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_ID_5
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_5 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_5_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_5_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_5");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_5

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_ID_6
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_6 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_6_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_6_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_6");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_6

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_STATUS_0
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_0_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_0_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_0

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_STATUS_1
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_1_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_1_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_1

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.DEVICE_RESET
    class I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_RESET extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_RESET_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_RESET_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_RESET");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_RESET

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.RECOVERY_CTRL
    class I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_CTRL_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_CTRL_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_CTRL

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.RECOVERY_STATUS
    class I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_STATUS_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_STATUS_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_STATUS

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.HW_STATUS
    class I3CCSR__I3C_EC__SecFwRecoveryIf__HW_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__HW_STATUS_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__HW_STATUS_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__HW_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__HW_STATUS

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_CTRL_0
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_0_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_0_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_0

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_CTRL_1
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_1_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_1_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_1

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_STATUS_0
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_0_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_0_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_0

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_STATUS_1
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_1_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_1_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_1

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_STATUS_2
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_2 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_2_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_2_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_2");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_2

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_STATUS_3
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_3 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_3_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_3_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_3");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_3

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_STATUS_4
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_4 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_4_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_4_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_4");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_4

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_STATUS_5
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_5 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_5_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_5_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_5");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_5

    // Reg - I3CCSR.I3C_EC.SecFwRecoveryIf.INDIRECT_FIFO_DATA
    class I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_DATA extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_DATA_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_DATA_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_DATA");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_DATA

    // Regfile - I3CCSR.I3C_EC.SecFwRecoveryIf
    class I3CCSR__I3C_EC__SecFwRecoveryIf extends uvm_reg_block;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__EXTCAP_HEADER EXTCAP_HEADER;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_0 PROT_CAP_0;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_1 PROT_CAP_1;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_2 PROT_CAP_2;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__PROT_CAP_3 PROT_CAP_3;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_0 DEVICE_ID_0;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_1 DEVICE_ID_1;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_2 DEVICE_ID_2;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_3 DEVICE_ID_3;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_4 DEVICE_ID_4;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_5 DEVICE_ID_5;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_ID_6 DEVICE_ID_6;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_0 DEVICE_STATUS_0;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_STATUS_1 DEVICE_STATUS_1;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__DEVICE_RESET DEVICE_RESET;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_CTRL RECOVERY_CTRL;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__RECOVERY_STATUS RECOVERY_STATUS;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__HW_STATUS HW_STATUS;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_0 INDIRECT_FIFO_CTRL_0;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_CTRL_1 INDIRECT_FIFO_CTRL_1;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_0 INDIRECT_FIFO_STATUS_0;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_1 INDIRECT_FIFO_STATUS_1;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_2 INDIRECT_FIFO_STATUS_2;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_3 INDIRECT_FIFO_STATUS_3;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_4 INDIRECT_FIFO_STATUS_4;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_STATUS_5 INDIRECT_FIFO_STATUS_5;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf__INDIRECT_FIFO_DATA INDIRECT_FIFO_DATA;

        function new(string name = "I3CCSR__I3C_EC__SecFwRecoveryIf");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.EXTCAP_HEADER = new("EXTCAP_HEADER");
            this.EXTCAP_HEADER.configure(this);

            this.EXTCAP_HEADER.build();
            this.default_map.add_reg(this.EXTCAP_HEADER, 'h0);
            this.PROT_CAP_0 = new("PROT_CAP_0");
            this.PROT_CAP_0.configure(this);

            this.PROT_CAP_0.build();
            this.default_map.add_reg(this.PROT_CAP_0, 'h4);
            this.PROT_CAP_1 = new("PROT_CAP_1");
            this.PROT_CAP_1.configure(this);

            this.PROT_CAP_1.build();
            this.default_map.add_reg(this.PROT_CAP_1, 'h8);
            this.PROT_CAP_2 = new("PROT_CAP_2");
            this.PROT_CAP_2.configure(this);

            this.PROT_CAP_2.build();
            this.default_map.add_reg(this.PROT_CAP_2, 'hc);
            this.PROT_CAP_3 = new("PROT_CAP_3");
            this.PROT_CAP_3.configure(this);

            this.PROT_CAP_3.build();
            this.default_map.add_reg(this.PROT_CAP_3, 'h10);
            this.DEVICE_ID_0 = new("DEVICE_ID_0");
            this.DEVICE_ID_0.configure(this);

            this.DEVICE_ID_0.build();
            this.default_map.add_reg(this.DEVICE_ID_0, 'h14);
            this.DEVICE_ID_1 = new("DEVICE_ID_1");
            this.DEVICE_ID_1.configure(this);

            this.DEVICE_ID_1.build();
            this.default_map.add_reg(this.DEVICE_ID_1, 'h18);
            this.DEVICE_ID_2 = new("DEVICE_ID_2");
            this.DEVICE_ID_2.configure(this);

            this.DEVICE_ID_2.build();
            this.default_map.add_reg(this.DEVICE_ID_2, 'h1c);
            this.DEVICE_ID_3 = new("DEVICE_ID_3");
            this.DEVICE_ID_3.configure(this);

            this.DEVICE_ID_3.build();
            this.default_map.add_reg(this.DEVICE_ID_3, 'h20);
            this.DEVICE_ID_4 = new("DEVICE_ID_4");
            this.DEVICE_ID_4.configure(this);

            this.DEVICE_ID_4.build();
            this.default_map.add_reg(this.DEVICE_ID_4, 'h24);
            this.DEVICE_ID_5 = new("DEVICE_ID_5");
            this.DEVICE_ID_5.configure(this);

            this.DEVICE_ID_5.build();
            this.default_map.add_reg(this.DEVICE_ID_5, 'h28);
            this.DEVICE_ID_6 = new("DEVICE_ID_6");
            this.DEVICE_ID_6.configure(this);

            this.DEVICE_ID_6.build();
            this.default_map.add_reg(this.DEVICE_ID_6, 'h2c);
            this.DEVICE_STATUS_0 = new("DEVICE_STATUS_0");
            this.DEVICE_STATUS_0.configure(this);

            this.DEVICE_STATUS_0.build();
            this.default_map.add_reg(this.DEVICE_STATUS_0, 'h30);
            this.DEVICE_STATUS_1 = new("DEVICE_STATUS_1");
            this.DEVICE_STATUS_1.configure(this);

            this.DEVICE_STATUS_1.build();
            this.default_map.add_reg(this.DEVICE_STATUS_1, 'h34);
            this.DEVICE_RESET = new("DEVICE_RESET");
            this.DEVICE_RESET.configure(this);

            this.DEVICE_RESET.build();
            this.default_map.add_reg(this.DEVICE_RESET, 'h38);
            this.RECOVERY_CTRL = new("RECOVERY_CTRL");
            this.RECOVERY_CTRL.configure(this);

            this.RECOVERY_CTRL.build();
            this.default_map.add_reg(this.RECOVERY_CTRL, 'h3c);
            this.RECOVERY_STATUS = new("RECOVERY_STATUS");
            this.RECOVERY_STATUS.configure(this);

            this.RECOVERY_STATUS.build();
            this.default_map.add_reg(this.RECOVERY_STATUS, 'h40);
            this.HW_STATUS = new("HW_STATUS");
            this.HW_STATUS.configure(this);

            this.HW_STATUS.build();
            this.default_map.add_reg(this.HW_STATUS, 'h44);
            this.INDIRECT_FIFO_CTRL_0 = new("INDIRECT_FIFO_CTRL_0");
            this.INDIRECT_FIFO_CTRL_0.configure(this);

            this.INDIRECT_FIFO_CTRL_0.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_CTRL_0, 'h48);
            this.INDIRECT_FIFO_CTRL_1 = new("INDIRECT_FIFO_CTRL_1");
            this.INDIRECT_FIFO_CTRL_1.configure(this);

            this.INDIRECT_FIFO_CTRL_1.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_CTRL_1, 'h4c);
            this.INDIRECT_FIFO_STATUS_0 = new("INDIRECT_FIFO_STATUS_0");
            this.INDIRECT_FIFO_STATUS_0.configure(this);

            this.INDIRECT_FIFO_STATUS_0.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_STATUS_0, 'h50);
            this.INDIRECT_FIFO_STATUS_1 = new("INDIRECT_FIFO_STATUS_1");
            this.INDIRECT_FIFO_STATUS_1.configure(this);

            this.INDIRECT_FIFO_STATUS_1.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_STATUS_1, 'h54);
            this.INDIRECT_FIFO_STATUS_2 = new("INDIRECT_FIFO_STATUS_2");
            this.INDIRECT_FIFO_STATUS_2.configure(this);

            this.INDIRECT_FIFO_STATUS_2.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_STATUS_2, 'h58);
            this.INDIRECT_FIFO_STATUS_3 = new("INDIRECT_FIFO_STATUS_3");
            this.INDIRECT_FIFO_STATUS_3.configure(this);

            this.INDIRECT_FIFO_STATUS_3.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_STATUS_3, 'h5c);
            this.INDIRECT_FIFO_STATUS_4 = new("INDIRECT_FIFO_STATUS_4");
            this.INDIRECT_FIFO_STATUS_4.configure(this);

            this.INDIRECT_FIFO_STATUS_4.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_STATUS_4, 'h60);
            this.INDIRECT_FIFO_STATUS_5 = new("INDIRECT_FIFO_STATUS_5");
            this.INDIRECT_FIFO_STATUS_5.configure(this);

            this.INDIRECT_FIFO_STATUS_5.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_STATUS_5, 'h64);
            this.INDIRECT_FIFO_DATA = new("INDIRECT_FIFO_DATA");
            this.INDIRECT_FIFO_DATA.configure(this);

            this.INDIRECT_FIFO_DATA.build();
            this.default_map.add_reg(this.INDIRECT_FIFO_DATA, 'h68);
        endfunction : build
    endclass : I3CCSR__I3C_EC__SecFwRecoveryIf

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.EXTCAP_HEADER
    class I3CCSR__I3C_EC__StdbyCtrlMode__EXTCAP_HEADER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__EXTCAP_HEADER_bit_cg [8-1:0]CAP_ID_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__EXTCAP_HEADER_bit_cg [16-1:0]CAP_LENGTH_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__EXTCAP_HEADER_fld_cg fld_cg;
        rand uvm_reg_field CAP_ID;
        rand uvm_reg_field CAP_LENGTH;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__EXTCAP_HEADER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CAP_ID = new("CAP_ID");
            this.CAP_ID.configure(this, 8, 0, "RO", 0, 'h12, 1, 1, 0);
            this.CAP_LENGTH = new("CAP_LENGTH");
            this.CAP_LENGTH.configure(this, 16, 8, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CAP_ID_bit_cg[bt]) CAP_ID_bit_cg[bt] = new();
                foreach(CAP_LENGTH_bit_cg[bt]) CAP_LENGTH_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__EXTCAP_HEADER

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_CONTROL
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]PENDING_RX_NACK_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]HANDOFF_DELAY_NACK_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]ACR_FSM_OP_SELECT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]PRIME_ACCEPT_GETACCCR_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]HANDOFF_DEEP_SLEEP_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]CR_REQUEST_SEND_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [3-1:0]BAST_CCC_IBI_RING_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]TARGET_XACT_ENABLE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]DAA_SETAASA_ENABLE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]DAA_SETDASA_ENABLE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]DAA_ENTDAA_ENABLE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [1-1:0]RSTACT_DEFBYTE_02_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_bit_cg [2-1:0]STBY_CR_ENABLE_INIT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL_fld_cg fld_cg;
        rand uvm_reg_field PENDING_RX_NACK;
        rand uvm_reg_field HANDOFF_DELAY_NACK;
        rand uvm_reg_field ACR_FSM_OP_SELECT;
        rand uvm_reg_field PRIME_ACCEPT_GETACCCR;
        rand uvm_reg_field HANDOFF_DEEP_SLEEP;
        rand uvm_reg_field CR_REQUEST_SEND;
        rand uvm_reg_field BAST_CCC_IBI_RING;
        rand uvm_reg_field TARGET_XACT_ENABLE;
        rand uvm_reg_field DAA_SETAASA_ENABLE;
        rand uvm_reg_field DAA_SETDASA_ENABLE;
        rand uvm_reg_field DAA_ENTDAA_ENABLE;
        rand uvm_reg_field RSTACT_DEFBYTE_02;
        rand uvm_reg_field STBY_CR_ENABLE_INIT;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PENDING_RX_NACK = new("PENDING_RX_NACK");
            this.PENDING_RX_NACK.configure(this, 1, 0, "RW", 1, 'h0, 0, 1, 0);
            this.HANDOFF_DELAY_NACK = new("HANDOFF_DELAY_NACK");
            this.HANDOFF_DELAY_NACK.configure(this, 1, 1, "RW", 1, 'h0, 0, 1, 0);
            this.ACR_FSM_OP_SELECT = new("ACR_FSM_OP_SELECT");
            this.ACR_FSM_OP_SELECT.configure(this, 1, 2, "RW", 1, 'h0, 0, 1, 0);
            this.PRIME_ACCEPT_GETACCCR = new("PRIME_ACCEPT_GETACCCR");
            this.PRIME_ACCEPT_GETACCCR.configure(this, 1, 3, "RW", 1, 'h0, 0, 1, 0);
            this.HANDOFF_DEEP_SLEEP = new("HANDOFF_DEEP_SLEEP");
            this.HANDOFF_DEEP_SLEEP.configure(this, 1, 4, "RW", 1, 'h0, 1, 1, 0);
            this.CR_REQUEST_SEND = new("CR_REQUEST_SEND");
            this.CR_REQUEST_SEND.configure(this, 1, 5, "RW", 1, 'h0, 1, 1, 0);
            this.BAST_CCC_IBI_RING = new("BAST_CCC_IBI_RING");
            this.BAST_CCC_IBI_RING.configure(this, 3, 8, "RW", 1, 'h0, 1, 1, 0);
            this.TARGET_XACT_ENABLE = new("TARGET_XACT_ENABLE");
            this.TARGET_XACT_ENABLE.configure(this, 1, 12, "RW", 1, 'h0, 1, 1, 0);
            this.DAA_SETAASA_ENABLE = new("DAA_SETAASA_ENABLE");
            this.DAA_SETAASA_ENABLE.configure(this, 1, 13, "RW", 1, 'h0, 1, 1, 0);
            this.DAA_SETDASA_ENABLE = new("DAA_SETDASA_ENABLE");
            this.DAA_SETDASA_ENABLE.configure(this, 1, 14, "RW", 1, 'h0, 1, 1, 0);
            this.DAA_ENTDAA_ENABLE = new("DAA_ENTDAA_ENABLE");
            this.DAA_ENTDAA_ENABLE.configure(this, 1, 15, "RW", 1, 'h0, 1, 1, 0);
            this.RSTACT_DEFBYTE_02 = new("RSTACT_DEFBYTE_02");
            this.RSTACT_DEFBYTE_02.configure(this, 1, 20, "RW", 1, 'h0, 1, 1, 0);
            this.STBY_CR_ENABLE_INIT = new("STBY_CR_ENABLE_INIT");
            this.STBY_CR_ENABLE_INIT.configure(this, 2, 30, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PENDING_RX_NACK_bit_cg[bt]) PENDING_RX_NACK_bit_cg[bt] = new();
                foreach(HANDOFF_DELAY_NACK_bit_cg[bt]) HANDOFF_DELAY_NACK_bit_cg[bt] = new();
                foreach(ACR_FSM_OP_SELECT_bit_cg[bt]) ACR_FSM_OP_SELECT_bit_cg[bt] = new();
                foreach(PRIME_ACCEPT_GETACCCR_bit_cg[bt]) PRIME_ACCEPT_GETACCCR_bit_cg[bt] = new();
                foreach(HANDOFF_DEEP_SLEEP_bit_cg[bt]) HANDOFF_DEEP_SLEEP_bit_cg[bt] = new();
                foreach(CR_REQUEST_SEND_bit_cg[bt]) CR_REQUEST_SEND_bit_cg[bt] = new();
                foreach(BAST_CCC_IBI_RING_bit_cg[bt]) BAST_CCC_IBI_RING_bit_cg[bt] = new();
                foreach(TARGET_XACT_ENABLE_bit_cg[bt]) TARGET_XACT_ENABLE_bit_cg[bt] = new();
                foreach(DAA_SETAASA_ENABLE_bit_cg[bt]) DAA_SETAASA_ENABLE_bit_cg[bt] = new();
                foreach(DAA_SETDASA_ENABLE_bit_cg[bt]) DAA_SETDASA_ENABLE_bit_cg[bt] = new();
                foreach(DAA_ENTDAA_ENABLE_bit_cg[bt]) DAA_ENTDAA_ENABLE_bit_cg[bt] = new();
                foreach(RSTACT_DEFBYTE_02_bit_cg[bt]) RSTACT_DEFBYTE_02_bit_cg[bt] = new();
                foreach(STBY_CR_ENABLE_INIT_bit_cg[bt]) STBY_CR_ENABLE_INIT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_DEVICE_ADDR
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR_bit_cg [7-1:0]STATIC_ADDR_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR_bit_cg [1-1:0]STATIC_ADDR_VALID_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR_bit_cg [7-1:0]DYNAMIC_ADDR_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR_bit_cg [1-1:0]DYNAMIC_ADDR_VALID_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR_fld_cg fld_cg;
        rand uvm_reg_field STATIC_ADDR;
        rand uvm_reg_field STATIC_ADDR_VALID;
        rand uvm_reg_field DYNAMIC_ADDR;
        rand uvm_reg_field DYNAMIC_ADDR_VALID;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.STATIC_ADDR = new("STATIC_ADDR");
            this.STATIC_ADDR.configure(this, 7, 0, "RW", 1, 'h0, 0, 1, 0);
            this.STATIC_ADDR_VALID = new("STATIC_ADDR_VALID");
            this.STATIC_ADDR_VALID.configure(this, 1, 15, "RW", 1, 'h0, 0, 1, 0);
            this.DYNAMIC_ADDR = new("DYNAMIC_ADDR");
            this.DYNAMIC_ADDR.configure(this, 7, 16, "RW", 1, 'h0, 0, 1, 0);
            this.DYNAMIC_ADDR_VALID = new("DYNAMIC_ADDR_VALID");
            this.DYNAMIC_ADDR_VALID.configure(this, 1, 31, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(STATIC_ADDR_bit_cg[bt]) STATIC_ADDR_bit_cg[bt] = new();
                foreach(STATIC_ADDR_VALID_bit_cg[bt]) STATIC_ADDR_VALID_bit_cg[bt] = new();
                foreach(DYNAMIC_ADDR_bit_cg[bt]) DYNAMIC_ADDR_bit_cg[bt] = new();
                foreach(DYNAMIC_ADDR_VALID_bit_cg[bt]) DYNAMIC_ADDR_VALID_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_CAPABILITIES
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES_bit_cg [1-1:0]SIMPLE_CRR_SUPPORT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES_bit_cg [1-1:0]TARGET_XACT_SUPPORT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES_bit_cg [1-1:0]DAA_SETAASA_SUPPORT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES_bit_cg [1-1:0]DAA_SETDASA_SUPPORT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES_bit_cg [1-1:0]DAA_ENTDAA_SUPPORT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES_fld_cg fld_cg;
        rand uvm_reg_field SIMPLE_CRR_SUPPORT;
        rand uvm_reg_field TARGET_XACT_SUPPORT;
        rand uvm_reg_field DAA_SETAASA_SUPPORT;
        rand uvm_reg_field DAA_SETDASA_SUPPORT;
        rand uvm_reg_field DAA_ENTDAA_SUPPORT;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.SIMPLE_CRR_SUPPORT = new("SIMPLE_CRR_SUPPORT");
            this.SIMPLE_CRR_SUPPORT.configure(this, 1, 5, "RW", 1, 'h0, 0, 1, 0);
            this.TARGET_XACT_SUPPORT = new("TARGET_XACT_SUPPORT");
            this.TARGET_XACT_SUPPORT.configure(this, 1, 12, "RW", 1, 'h0, 0, 1, 0);
            this.DAA_SETAASA_SUPPORT = new("DAA_SETAASA_SUPPORT");
            this.DAA_SETAASA_SUPPORT.configure(this, 1, 13, "RW", 1, 'h0, 0, 1, 0);
            this.DAA_SETDASA_SUPPORT = new("DAA_SETDASA_SUPPORT");
            this.DAA_SETDASA_SUPPORT.configure(this, 1, 14, "RW", 1, 'h0, 0, 1, 0);
            this.DAA_ENTDAA_SUPPORT = new("DAA_ENTDAA_SUPPORT");
            this.DAA_ENTDAA_SUPPORT.configure(this, 1, 15, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(SIMPLE_CRR_SUPPORT_bit_cg[bt]) SIMPLE_CRR_SUPPORT_bit_cg[bt] = new();
                foreach(TARGET_XACT_SUPPORT_bit_cg[bt]) TARGET_XACT_SUPPORT_bit_cg[bt] = new();
                foreach(DAA_SETAASA_SUPPORT_bit_cg[bt]) DAA_SETAASA_SUPPORT_bit_cg[bt] = new();
                foreach(DAA_SETDASA_SUPPORT_bit_cg[bt]) DAA_SETDASA_SUPPORT_bit_cg[bt] = new();
                foreach(DAA_ENTDAA_SUPPORT_bit_cg[bt]) DAA_ENTDAA_SUPPORT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.__rsvd_0
    class I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_0_bit_cg [32-1:0]__rsvd_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_0_fld_cg fld_cg;
        rand uvm_reg_field __rsvd;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.__rsvd = new("__rsvd");
            this.__rsvd.configure(this, 32, 0, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(__rsvd_bit_cg[bt]) __rsvd_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_0

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_STATUS
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS_bit_cg [1-1:0]AC_CURRENT_OWN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS_bit_cg [3-1:0]SIMPLE_CRR_STATUS_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS_bit_cg [1-1:0]HJ_REQ_STATUS_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS_fld_cg fld_cg;
        rand uvm_reg_field AC_CURRENT_OWN;
        rand uvm_reg_field SIMPLE_CRR_STATUS;
        rand uvm_reg_field HJ_REQ_STATUS;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.AC_CURRENT_OWN = new("AC_CURRENT_OWN");
            this.AC_CURRENT_OWN.configure(this, 1, 2, "RW", 1, 'h0, 0, 1, 0);
            this.SIMPLE_CRR_STATUS = new("SIMPLE_CRR_STATUS");
            this.SIMPLE_CRR_STATUS.configure(this, 3, 5, "RW", 1, 'h0, 0, 1, 0);
            this.HJ_REQ_STATUS = new("HJ_REQ_STATUS");
            this.HJ_REQ_STATUS.configure(this, 1, 8, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(AC_CURRENT_OWN_bit_cg[bt]) AC_CURRENT_OWN_bit_cg[bt] = new();
                foreach(SIMPLE_CRR_STATUS_bit_cg[bt]) SIMPLE_CRR_STATUS_bit_cg[bt] = new();
                foreach(HJ_REQ_STATUS_bit_cg[bt]) HJ_REQ_STATUS_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_DEVICE_CHAR
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR_bit_cg [15-1:0]PID_HI_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR_bit_cg [8-1:0]DCR_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR_bit_cg [5-1:0]BCR_VAR_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR_bit_cg [3-1:0]BCR_FIXED_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR_fld_cg fld_cg;
        rand uvm_reg_field PID_HI;
        rand uvm_reg_field DCR;
        rand uvm_reg_field BCR_VAR;
        rand uvm_reg_field BCR_FIXED;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PID_HI = new("PID_HI");
            this.PID_HI.configure(this, 15, 1, "RW", 1, 'h0, 0, 1, 0);
            this.DCR = new("DCR");
            this.DCR.configure(this, 8, 16, "RW", 1, 'h0, 0, 1, 0);
            this.BCR_VAR = new("BCR_VAR");
            this.BCR_VAR.configure(this, 5, 24, "RW", 1, 'h0, 0, 1, 0);
            this.BCR_FIXED = new("BCR_FIXED");
            this.BCR_FIXED.configure(this, 3, 29, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PID_HI_bit_cg[bt]) PID_HI_bit_cg[bt] = new();
                foreach(DCR_bit_cg[bt]) DCR_bit_cg[bt] = new();
                foreach(BCR_VAR_bit_cg[bt]) BCR_VAR_bit_cg[bt] = new();
                foreach(BCR_FIXED_bit_cg[bt]) BCR_FIXED_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_DEVICE_PID_LO
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_PID_LO extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_PID_LO_bit_cg [32-1:0]PID_LO_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_PID_LO_fld_cg fld_cg;
        rand uvm_reg_field PID_LO;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_PID_LO");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PID_LO = new("PID_LO");
            this.PID_LO.configure(this, 32, 0, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PID_LO_bit_cg[bt]) PID_LO_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_PID_LO

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_INTR_STATUS
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]ACR_HANDOFF_OK_REMAIN_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]ACR_HANDOFF_OK_PRIMED_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]ACR_HANDOFF_ERR_FAIL_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]ACR_HANDOFF_ERR_M3_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]CRR_RESPONSE_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]STBY_CR_DYN_ADDR_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]STBY_CR_ACCEPT_NACKED_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]STBY_CR_ACCEPT_OK_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]STBY_CR_ACCEPT_ERR_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]STBY_CR_OP_RSTACT_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]CCC_PARAM_MODIFIED_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]CCC_UNHANDLED_NACK_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_bit_cg [1-1:0]CCC_FATAL_RSTDAA_ERR_STAT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS_fld_cg fld_cg;
        rand uvm_reg_field ACR_HANDOFF_OK_REMAIN_STAT;
        rand uvm_reg_field ACR_HANDOFF_OK_PRIMED_STAT;
        rand uvm_reg_field ACR_HANDOFF_ERR_FAIL_STAT;
        rand uvm_reg_field ACR_HANDOFF_ERR_M3_STAT;
        rand uvm_reg_field CRR_RESPONSE_STAT;
        rand uvm_reg_field STBY_CR_DYN_ADDR_STAT;
        rand uvm_reg_field STBY_CR_ACCEPT_NACKED_STAT;
        rand uvm_reg_field STBY_CR_ACCEPT_OK_STAT;
        rand uvm_reg_field STBY_CR_ACCEPT_ERR_STAT;
        rand uvm_reg_field STBY_CR_OP_RSTACT_STAT;
        rand uvm_reg_field CCC_PARAM_MODIFIED_STAT;
        rand uvm_reg_field CCC_UNHANDLED_NACK_STAT;
        rand uvm_reg_field CCC_FATAL_RSTDAA_ERR_STAT;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ACR_HANDOFF_OK_REMAIN_STAT = new("ACR_HANDOFF_OK_REMAIN_STAT");
            this.ACR_HANDOFF_OK_REMAIN_STAT.configure(this, 1, 0, "RW", 1, 'h0, 0, 1, 0);
            this.ACR_HANDOFF_OK_PRIMED_STAT = new("ACR_HANDOFF_OK_PRIMED_STAT");
            this.ACR_HANDOFF_OK_PRIMED_STAT.configure(this, 1, 1, "RW", 1, 'h0, 0, 1, 0);
            this.ACR_HANDOFF_ERR_FAIL_STAT = new("ACR_HANDOFF_ERR_FAIL_STAT");
            this.ACR_HANDOFF_ERR_FAIL_STAT.configure(this, 1, 2, "RW", 1, 'h0, 0, 1, 0);
            this.ACR_HANDOFF_ERR_M3_STAT = new("ACR_HANDOFF_ERR_M3_STAT");
            this.ACR_HANDOFF_ERR_M3_STAT.configure(this, 1, 3, "RW", 1, 'h0, 0, 1, 0);
            this.CRR_RESPONSE_STAT = new("CRR_RESPONSE_STAT");
            this.CRR_RESPONSE_STAT.configure(this, 1, 10, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_DYN_ADDR_STAT = new("STBY_CR_DYN_ADDR_STAT");
            this.STBY_CR_DYN_ADDR_STAT.configure(this, 1, 11, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_NACKED_STAT = new("STBY_CR_ACCEPT_NACKED_STAT");
            this.STBY_CR_ACCEPT_NACKED_STAT.configure(this, 1, 12, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_OK_STAT = new("STBY_CR_ACCEPT_OK_STAT");
            this.STBY_CR_ACCEPT_OK_STAT.configure(this, 1, 13, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_ERR_STAT = new("STBY_CR_ACCEPT_ERR_STAT");
            this.STBY_CR_ACCEPT_ERR_STAT.configure(this, 1, 14, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_OP_RSTACT_STAT = new("STBY_CR_OP_RSTACT_STAT");
            this.STBY_CR_OP_RSTACT_STAT.configure(this, 1, 16, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_PARAM_MODIFIED_STAT = new("CCC_PARAM_MODIFIED_STAT");
            this.CCC_PARAM_MODIFIED_STAT.configure(this, 1, 17, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_UNHANDLED_NACK_STAT = new("CCC_UNHANDLED_NACK_STAT");
            this.CCC_UNHANDLED_NACK_STAT.configure(this, 1, 18, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_FATAL_RSTDAA_ERR_STAT = new("CCC_FATAL_RSTDAA_ERR_STAT");
            this.CCC_FATAL_RSTDAA_ERR_STAT.configure(this, 1, 19, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ACR_HANDOFF_OK_REMAIN_STAT_bit_cg[bt]) ACR_HANDOFF_OK_REMAIN_STAT_bit_cg[bt] = new();
                foreach(ACR_HANDOFF_OK_PRIMED_STAT_bit_cg[bt]) ACR_HANDOFF_OK_PRIMED_STAT_bit_cg[bt] = new();
                foreach(ACR_HANDOFF_ERR_FAIL_STAT_bit_cg[bt]) ACR_HANDOFF_ERR_FAIL_STAT_bit_cg[bt] = new();
                foreach(ACR_HANDOFF_ERR_M3_STAT_bit_cg[bt]) ACR_HANDOFF_ERR_M3_STAT_bit_cg[bt] = new();
                foreach(CRR_RESPONSE_STAT_bit_cg[bt]) CRR_RESPONSE_STAT_bit_cg[bt] = new();
                foreach(STBY_CR_DYN_ADDR_STAT_bit_cg[bt]) STBY_CR_DYN_ADDR_STAT_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_NACKED_STAT_bit_cg[bt]) STBY_CR_ACCEPT_NACKED_STAT_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_OK_STAT_bit_cg[bt]) STBY_CR_ACCEPT_OK_STAT_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_ERR_STAT_bit_cg[bt]) STBY_CR_ACCEPT_ERR_STAT_bit_cg[bt] = new();
                foreach(STBY_CR_OP_RSTACT_STAT_bit_cg[bt]) STBY_CR_OP_RSTACT_STAT_bit_cg[bt] = new();
                foreach(CCC_PARAM_MODIFIED_STAT_bit_cg[bt]) CCC_PARAM_MODIFIED_STAT_bit_cg[bt] = new();
                foreach(CCC_UNHANDLED_NACK_STAT_bit_cg[bt]) CCC_UNHANDLED_NACK_STAT_bit_cg[bt] = new();
                foreach(CCC_FATAL_RSTDAA_ERR_STAT_bit_cg[bt]) CCC_FATAL_RSTDAA_ERR_STAT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.__rsvd_1
    class I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_1_bit_cg [32-1:0]__rsvd_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_1_fld_cg fld_cg;
        rand uvm_reg_field __rsvd;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.__rsvd = new("__rsvd");
            this.__rsvd.configure(this, 32, 0, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(__rsvd_bit_cg[bt]) __rsvd_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_1

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_INTR_SIGNAL_ENABLE
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]ACR_HANDOFF_OK_REMAIN_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]ACR_HANDOFF_OK_PRIMED_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]ACR_HANDOFF_ERR_FAIL_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]ACR_HANDOFF_ERR_M3_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]CRR_RESPONSE_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]STBY_CR_DYN_ADDR_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]STBY_CR_ACCEPT_NACKED_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]STBY_CR_ACCEPT_OK_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]STBY_CR_ACCEPT_ERR_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]STBY_CR_OP_RSTACT_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]CCC_PARAM_MODIFIED_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]CCC_UNHANDLED_NACK_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_bit_cg [1-1:0]CCC_FATAL_RSTDAA_ERR_SIGNAL_EN_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE_fld_cg fld_cg;
        rand uvm_reg_field ACR_HANDOFF_OK_REMAIN_SIGNAL_EN;
        rand uvm_reg_field ACR_HANDOFF_OK_PRIMED_SIGNAL_EN;
        rand uvm_reg_field ACR_HANDOFF_ERR_FAIL_SIGNAL_EN;
        rand uvm_reg_field ACR_HANDOFF_ERR_M3_SIGNAL_EN;
        rand uvm_reg_field CRR_RESPONSE_SIGNAL_EN;
        rand uvm_reg_field STBY_CR_DYN_ADDR_SIGNAL_EN;
        rand uvm_reg_field STBY_CR_ACCEPT_NACKED_SIGNAL_EN;
        rand uvm_reg_field STBY_CR_ACCEPT_OK_SIGNAL_EN;
        rand uvm_reg_field STBY_CR_ACCEPT_ERR_SIGNAL_EN;
        rand uvm_reg_field STBY_CR_OP_RSTACT_SIGNAL_EN;
        rand uvm_reg_field CCC_PARAM_MODIFIED_SIGNAL_EN;
        rand uvm_reg_field CCC_UNHANDLED_NACK_SIGNAL_EN;
        rand uvm_reg_field CCC_FATAL_RSTDAA_ERR_SIGNAL_EN;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ACR_HANDOFF_OK_REMAIN_SIGNAL_EN = new("ACR_HANDOFF_OK_REMAIN_SIGNAL_EN");
            this.ACR_HANDOFF_OK_REMAIN_SIGNAL_EN.configure(this, 1, 0, "RW", 1, 'h0, 0, 1, 0);
            this.ACR_HANDOFF_OK_PRIMED_SIGNAL_EN = new("ACR_HANDOFF_OK_PRIMED_SIGNAL_EN");
            this.ACR_HANDOFF_OK_PRIMED_SIGNAL_EN.configure(this, 1, 1, "RW", 1, 'h0, 0, 1, 0);
            this.ACR_HANDOFF_ERR_FAIL_SIGNAL_EN = new("ACR_HANDOFF_ERR_FAIL_SIGNAL_EN");
            this.ACR_HANDOFF_ERR_FAIL_SIGNAL_EN.configure(this, 1, 2, "RW", 1, 'h0, 0, 1, 0);
            this.ACR_HANDOFF_ERR_M3_SIGNAL_EN = new("ACR_HANDOFF_ERR_M3_SIGNAL_EN");
            this.ACR_HANDOFF_ERR_M3_SIGNAL_EN.configure(this, 1, 3, "RW", 1, 'h0, 0, 1, 0);
            this.CRR_RESPONSE_SIGNAL_EN = new("CRR_RESPONSE_SIGNAL_EN");
            this.CRR_RESPONSE_SIGNAL_EN.configure(this, 1, 10, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_DYN_ADDR_SIGNAL_EN = new("STBY_CR_DYN_ADDR_SIGNAL_EN");
            this.STBY_CR_DYN_ADDR_SIGNAL_EN.configure(this, 1, 11, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_NACKED_SIGNAL_EN = new("STBY_CR_ACCEPT_NACKED_SIGNAL_EN");
            this.STBY_CR_ACCEPT_NACKED_SIGNAL_EN.configure(this, 1, 12, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_OK_SIGNAL_EN = new("STBY_CR_ACCEPT_OK_SIGNAL_EN");
            this.STBY_CR_ACCEPT_OK_SIGNAL_EN.configure(this, 1, 13, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_ERR_SIGNAL_EN = new("STBY_CR_ACCEPT_ERR_SIGNAL_EN");
            this.STBY_CR_ACCEPT_ERR_SIGNAL_EN.configure(this, 1, 14, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_OP_RSTACT_SIGNAL_EN = new("STBY_CR_OP_RSTACT_SIGNAL_EN");
            this.STBY_CR_OP_RSTACT_SIGNAL_EN.configure(this, 1, 16, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_PARAM_MODIFIED_SIGNAL_EN = new("CCC_PARAM_MODIFIED_SIGNAL_EN");
            this.CCC_PARAM_MODIFIED_SIGNAL_EN.configure(this, 1, 17, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_UNHANDLED_NACK_SIGNAL_EN = new("CCC_UNHANDLED_NACK_SIGNAL_EN");
            this.CCC_UNHANDLED_NACK_SIGNAL_EN.configure(this, 1, 18, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_FATAL_RSTDAA_ERR_SIGNAL_EN = new("CCC_FATAL_RSTDAA_ERR_SIGNAL_EN");
            this.CCC_FATAL_RSTDAA_ERR_SIGNAL_EN.configure(this, 1, 19, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ACR_HANDOFF_OK_REMAIN_SIGNAL_EN_bit_cg[bt]) ACR_HANDOFF_OK_REMAIN_SIGNAL_EN_bit_cg[bt] = new();
                foreach(ACR_HANDOFF_OK_PRIMED_SIGNAL_EN_bit_cg[bt]) ACR_HANDOFF_OK_PRIMED_SIGNAL_EN_bit_cg[bt] = new();
                foreach(ACR_HANDOFF_ERR_FAIL_SIGNAL_EN_bit_cg[bt]) ACR_HANDOFF_ERR_FAIL_SIGNAL_EN_bit_cg[bt] = new();
                foreach(ACR_HANDOFF_ERR_M3_SIGNAL_EN_bit_cg[bt]) ACR_HANDOFF_ERR_M3_SIGNAL_EN_bit_cg[bt] = new();
                foreach(CRR_RESPONSE_SIGNAL_EN_bit_cg[bt]) CRR_RESPONSE_SIGNAL_EN_bit_cg[bt] = new();
                foreach(STBY_CR_DYN_ADDR_SIGNAL_EN_bit_cg[bt]) STBY_CR_DYN_ADDR_SIGNAL_EN_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_NACKED_SIGNAL_EN_bit_cg[bt]) STBY_CR_ACCEPT_NACKED_SIGNAL_EN_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_OK_SIGNAL_EN_bit_cg[bt]) STBY_CR_ACCEPT_OK_SIGNAL_EN_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_ERR_SIGNAL_EN_bit_cg[bt]) STBY_CR_ACCEPT_ERR_SIGNAL_EN_bit_cg[bt] = new();
                foreach(STBY_CR_OP_RSTACT_SIGNAL_EN_bit_cg[bt]) STBY_CR_OP_RSTACT_SIGNAL_EN_bit_cg[bt] = new();
                foreach(CCC_PARAM_MODIFIED_SIGNAL_EN_bit_cg[bt]) CCC_PARAM_MODIFIED_SIGNAL_EN_bit_cg[bt] = new();
                foreach(CCC_UNHANDLED_NACK_SIGNAL_EN_bit_cg[bt]) CCC_UNHANDLED_NACK_SIGNAL_EN_bit_cg[bt] = new();
                foreach(CCC_FATAL_RSTDAA_ERR_SIGNAL_EN_bit_cg[bt]) CCC_FATAL_RSTDAA_ERR_SIGNAL_EN_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_INTR_FORCE
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]CRR_RESPONSE_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]STBY_CR_DYN_ADDR_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]STBY_CR_ACCEPT_NACKED_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]STBY_CR_ACCEPT_OK_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]STBY_CR_ACCEPT_ERR_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]STBY_CR_OP_RSTACT_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]CCC_PARAM_MODIFIED_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]CCC_UNHANDLED_NACK_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_bit_cg [1-1:0]CCC_FATAL_RSTDAA_ERR_FORCE_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE_fld_cg fld_cg;
        rand uvm_reg_field CRR_RESPONSE_FORCE;
        rand uvm_reg_field STBY_CR_DYN_ADDR_FORCE;
        rand uvm_reg_field STBY_CR_ACCEPT_NACKED_FORCE;
        rand uvm_reg_field STBY_CR_ACCEPT_OK_FORCE;
        rand uvm_reg_field STBY_CR_ACCEPT_ERR_FORCE;
        rand uvm_reg_field STBY_CR_OP_RSTACT_FORCE;
        rand uvm_reg_field CCC_PARAM_MODIFIED_FORCE;
        rand uvm_reg_field CCC_UNHANDLED_NACK_FORCE;
        rand uvm_reg_field CCC_FATAL_RSTDAA_ERR_FORCE;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CRR_RESPONSE_FORCE = new("CRR_RESPONSE_FORCE");
            this.CRR_RESPONSE_FORCE.configure(this, 1, 10, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_DYN_ADDR_FORCE = new("STBY_CR_DYN_ADDR_FORCE");
            this.STBY_CR_DYN_ADDR_FORCE.configure(this, 1, 11, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_NACKED_FORCE = new("STBY_CR_ACCEPT_NACKED_FORCE");
            this.STBY_CR_ACCEPT_NACKED_FORCE.configure(this, 1, 12, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_OK_FORCE = new("STBY_CR_ACCEPT_OK_FORCE");
            this.STBY_CR_ACCEPT_OK_FORCE.configure(this, 1, 13, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_ACCEPT_ERR_FORCE = new("STBY_CR_ACCEPT_ERR_FORCE");
            this.STBY_CR_ACCEPT_ERR_FORCE.configure(this, 1, 14, "RW", 1, 'h0, 0, 1, 0);
            this.STBY_CR_OP_RSTACT_FORCE = new("STBY_CR_OP_RSTACT_FORCE");
            this.STBY_CR_OP_RSTACT_FORCE.configure(this, 1, 16, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_PARAM_MODIFIED_FORCE = new("CCC_PARAM_MODIFIED_FORCE");
            this.CCC_PARAM_MODIFIED_FORCE.configure(this, 1, 17, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_UNHANDLED_NACK_FORCE = new("CCC_UNHANDLED_NACK_FORCE");
            this.CCC_UNHANDLED_NACK_FORCE.configure(this, 1, 18, "RW", 1, 'h0, 0, 1, 0);
            this.CCC_FATAL_RSTDAA_ERR_FORCE = new("CCC_FATAL_RSTDAA_ERR_FORCE");
            this.CCC_FATAL_RSTDAA_ERR_FORCE.configure(this, 1, 19, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CRR_RESPONSE_FORCE_bit_cg[bt]) CRR_RESPONSE_FORCE_bit_cg[bt] = new();
                foreach(STBY_CR_DYN_ADDR_FORCE_bit_cg[bt]) STBY_CR_DYN_ADDR_FORCE_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_NACKED_FORCE_bit_cg[bt]) STBY_CR_ACCEPT_NACKED_FORCE_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_OK_FORCE_bit_cg[bt]) STBY_CR_ACCEPT_OK_FORCE_bit_cg[bt] = new();
                foreach(STBY_CR_ACCEPT_ERR_FORCE_bit_cg[bt]) STBY_CR_ACCEPT_ERR_FORCE_bit_cg[bt] = new();
                foreach(STBY_CR_OP_RSTACT_FORCE_bit_cg[bt]) STBY_CR_OP_RSTACT_FORCE_bit_cg[bt] = new();
                foreach(CCC_PARAM_MODIFIED_FORCE_bit_cg[bt]) CCC_PARAM_MODIFIED_FORCE_bit_cg[bt] = new();
                foreach(CCC_UNHANDLED_NACK_FORCE_bit_cg[bt]) CCC_UNHANDLED_NACK_FORCE_bit_cg[bt] = new();
                foreach(CCC_FATAL_RSTDAA_ERR_FORCE_bit_cg[bt]) CCC_FATAL_RSTDAA_ERR_FORCE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_CCC_CONFIG_GETCAPS
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_GETCAPS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_GETCAPS_bit_cg [3-1:0]F2_CRCAP1_BUS_CONFIG_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_GETCAPS_bit_cg [4-1:0]F2_CRCAP2_DEV_INTERACT_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_GETCAPS_fld_cg fld_cg;
        rand uvm_reg_field F2_CRCAP1_BUS_CONFIG;
        rand uvm_reg_field F2_CRCAP2_DEV_INTERACT;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_GETCAPS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.F2_CRCAP1_BUS_CONFIG = new("F2_CRCAP1_BUS_CONFIG");
            this.F2_CRCAP1_BUS_CONFIG.configure(this, 3, 0, "RW", 1, 'h0, 0, 1, 0);
            this.F2_CRCAP2_DEV_INTERACT = new("F2_CRCAP2_DEV_INTERACT");
            this.F2_CRCAP2_DEV_INTERACT.configure(this, 4, 8, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(F2_CRCAP1_BUS_CONFIG_bit_cg[bt]) F2_CRCAP1_BUS_CONFIG_bit_cg[bt] = new();
                foreach(F2_CRCAP2_DEV_INTERACT_bit_cg[bt]) F2_CRCAP2_DEV_INTERACT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_GETCAPS

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.STBY_CR_CCC_CONFIG_RSTACT_PARAMS
    class I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS_bit_cg [8-1:0]RST_ACTION_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS_bit_cg [8-1:0]RESET_TIME_PERIPHERAL_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS_bit_cg [8-1:0]RESET_TIME_TARGET_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS_bit_cg [1-1:0]RESET_DYNAMIC_ADDR_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS_fld_cg fld_cg;
        rand uvm_reg_field RST_ACTION;
        rand uvm_reg_field RESET_TIME_PERIPHERAL;
        rand uvm_reg_field RESET_TIME_TARGET;
        rand uvm_reg_field RESET_DYNAMIC_ADDR;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RST_ACTION = new("RST_ACTION");
            this.RST_ACTION.configure(this, 8, 0, "RW", 1, 'h0, 0, 1, 0);
            this.RESET_TIME_PERIPHERAL = new("RESET_TIME_PERIPHERAL");
            this.RESET_TIME_PERIPHERAL.configure(this, 8, 8, "RW", 1, 'h0, 0, 1, 0);
            this.RESET_TIME_TARGET = new("RESET_TIME_TARGET");
            this.RESET_TIME_TARGET.configure(this, 8, 16, "RW", 1, 'h0, 0, 1, 0);
            this.RESET_DYNAMIC_ADDR = new("RESET_DYNAMIC_ADDR");
            this.RESET_DYNAMIC_ADDR.configure(this, 1, 31, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RST_ACTION_bit_cg[bt]) RST_ACTION_bit_cg[bt] = new();
                foreach(RESET_TIME_PERIPHERAL_bit_cg[bt]) RESET_TIME_PERIPHERAL_bit_cg[bt] = new();
                foreach(RESET_TIME_TARGET_bit_cg[bt]) RESET_TIME_TARGET_bit_cg[bt] = new();
                foreach(RESET_DYNAMIC_ADDR_bit_cg[bt]) RESET_DYNAMIC_ADDR_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.__rsvd_2
    class I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_2 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_2_bit_cg [32-1:0]__rsvd_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_2_fld_cg fld_cg;
        rand uvm_reg_field __rsvd;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_2");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.__rsvd = new("__rsvd");
            this.__rsvd.configure(this, 32, 0, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(__rsvd_bit_cg[bt]) __rsvd_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_2

    // Reg - I3CCSR.I3C_EC.StdbyCtrlMode.__rsvd_3
    class I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_3 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_3_bit_cg [32-1:0]__rsvd_bit_cg;
        I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_3_fld_cg fld_cg;
        rand uvm_reg_field __rsvd;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_3");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.__rsvd = new("__rsvd");
            this.__rsvd.configure(this, 32, 0, "RW", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(__rsvd_bit_cg[bt]) __rsvd_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_3

    // Regfile - I3CCSR.I3C_EC.StdbyCtrlMode
    class I3CCSR__I3C_EC__StdbyCtrlMode extends uvm_reg_block;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__EXTCAP_HEADER EXTCAP_HEADER;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CONTROL STBY_CR_CONTROL;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_ADDR STBY_CR_DEVICE_ADDR;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CAPABILITIES STBY_CR_CAPABILITIES;
        rand I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_0 __rsvd_0;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_STATUS STBY_CR_STATUS;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_CHAR STBY_CR_DEVICE_CHAR;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_DEVICE_PID_LO STBY_CR_DEVICE_PID_LO;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_STATUS STBY_CR_INTR_STATUS;
        rand I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_1 __rsvd_1;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_SIGNAL_ENABLE STBY_CR_INTR_SIGNAL_ENABLE;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_INTR_FORCE STBY_CR_INTR_FORCE;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_GETCAPS STBY_CR_CCC_CONFIG_GETCAPS;
        rand I3CCSR__I3C_EC__StdbyCtrlMode__STBY_CR_CCC_CONFIG_RSTACT_PARAMS STBY_CR_CCC_CONFIG_RSTACT_PARAMS;
        rand I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_2 __rsvd_2;
        rand I3CCSR__I3C_EC__StdbyCtrlMode____rsvd_3 __rsvd_3;

        function new(string name = "I3CCSR__I3C_EC__StdbyCtrlMode");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.EXTCAP_HEADER = new("EXTCAP_HEADER");
            this.EXTCAP_HEADER.configure(this);

            this.EXTCAP_HEADER.build();
            this.default_map.add_reg(this.EXTCAP_HEADER, 'h0);
            this.STBY_CR_CONTROL = new("STBY_CR_CONTROL");
            this.STBY_CR_CONTROL.configure(this);

            this.STBY_CR_CONTROL.build();
            this.default_map.add_reg(this.STBY_CR_CONTROL, 'h4);
            this.STBY_CR_DEVICE_ADDR = new("STBY_CR_DEVICE_ADDR");
            this.STBY_CR_DEVICE_ADDR.configure(this);

            this.STBY_CR_DEVICE_ADDR.build();
            this.default_map.add_reg(this.STBY_CR_DEVICE_ADDR, 'h8);
            this.STBY_CR_CAPABILITIES = new("STBY_CR_CAPABILITIES");
            this.STBY_CR_CAPABILITIES.configure(this);

            this.STBY_CR_CAPABILITIES.build();
            this.default_map.add_reg(this.STBY_CR_CAPABILITIES, 'hc);
            this.__rsvd_0 = new("__rsvd_0");
            this.__rsvd_0.configure(this);

            this.__rsvd_0.build();
            this.default_map.add_reg(this.__rsvd_0, 'h10);
            this.STBY_CR_STATUS = new("STBY_CR_STATUS");
            this.STBY_CR_STATUS.configure(this);

            this.STBY_CR_STATUS.build();
            this.default_map.add_reg(this.STBY_CR_STATUS, 'h14);
            this.STBY_CR_DEVICE_CHAR = new("STBY_CR_DEVICE_CHAR");
            this.STBY_CR_DEVICE_CHAR.configure(this);

            this.STBY_CR_DEVICE_CHAR.build();
            this.default_map.add_reg(this.STBY_CR_DEVICE_CHAR, 'h18);
            this.STBY_CR_DEVICE_PID_LO = new("STBY_CR_DEVICE_PID_LO");
            this.STBY_CR_DEVICE_PID_LO.configure(this);

            this.STBY_CR_DEVICE_PID_LO.build();
            this.default_map.add_reg(this.STBY_CR_DEVICE_PID_LO, 'h1c);
            this.STBY_CR_INTR_STATUS = new("STBY_CR_INTR_STATUS");
            this.STBY_CR_INTR_STATUS.configure(this);

            this.STBY_CR_INTR_STATUS.build();
            this.default_map.add_reg(this.STBY_CR_INTR_STATUS, 'h20);
            this.__rsvd_1 = new("__rsvd_1");
            this.__rsvd_1.configure(this);

            this.__rsvd_1.build();
            this.default_map.add_reg(this.__rsvd_1, 'h24);
            this.STBY_CR_INTR_SIGNAL_ENABLE = new("STBY_CR_INTR_SIGNAL_ENABLE");
            this.STBY_CR_INTR_SIGNAL_ENABLE.configure(this);

            this.STBY_CR_INTR_SIGNAL_ENABLE.build();
            this.default_map.add_reg(this.STBY_CR_INTR_SIGNAL_ENABLE, 'h28);
            this.STBY_CR_INTR_FORCE = new("STBY_CR_INTR_FORCE");
            this.STBY_CR_INTR_FORCE.configure(this);

            this.STBY_CR_INTR_FORCE.build();
            this.default_map.add_reg(this.STBY_CR_INTR_FORCE, 'h2c);
            this.STBY_CR_CCC_CONFIG_GETCAPS = new("STBY_CR_CCC_CONFIG_GETCAPS");
            this.STBY_CR_CCC_CONFIG_GETCAPS.configure(this);

            this.STBY_CR_CCC_CONFIG_GETCAPS.build();
            this.default_map.add_reg(this.STBY_CR_CCC_CONFIG_GETCAPS, 'h30);
            this.STBY_CR_CCC_CONFIG_RSTACT_PARAMS = new("STBY_CR_CCC_CONFIG_RSTACT_PARAMS");
            this.STBY_CR_CCC_CONFIG_RSTACT_PARAMS.configure(this);

            this.STBY_CR_CCC_CONFIG_RSTACT_PARAMS.build();
            this.default_map.add_reg(this.STBY_CR_CCC_CONFIG_RSTACT_PARAMS, 'h34);
            this.__rsvd_2 = new("__rsvd_2");
            this.__rsvd_2.configure(this);

            this.__rsvd_2.build();
            this.default_map.add_reg(this.__rsvd_2, 'h38);
            this.__rsvd_3 = new("__rsvd_3");
            this.__rsvd_3.configure(this);

            this.__rsvd_3.build();
            this.default_map.add_reg(this.__rsvd_3, 'h3c);
        endfunction : build
    endclass : I3CCSR__I3C_EC__StdbyCtrlMode

    // Reg - I3CCSR.I3C_EC.TTI.EXTCAP_HEADER
    class I3CCSR__I3C_EC__TTI__EXTCAP_HEADER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__EXTCAP_HEADER_bit_cg [8-1:0]CAP_ID_bit_cg;
        I3CCSR__I3C_EC__TTI__EXTCAP_HEADER_bit_cg [16-1:0]CAP_LENGTH_bit_cg;
        I3CCSR__I3C_EC__TTI__EXTCAP_HEADER_fld_cg fld_cg;
        rand uvm_reg_field CAP_ID;
        rand uvm_reg_field CAP_LENGTH;

        function new(string name = "I3CCSR__I3C_EC__TTI__EXTCAP_HEADER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CAP_ID = new("CAP_ID");
            this.CAP_ID.configure(this, 8, 0, "RO", 0, 'hc4, 1, 1, 0);
            this.CAP_LENGTH = new("CAP_LENGTH");
            this.CAP_LENGTH.configure(this, 16, 8, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CAP_ID_bit_cg[bt]) CAP_ID_bit_cg[bt] = new();
                foreach(CAP_LENGTH_bit_cg[bt]) CAP_LENGTH_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__EXTCAP_HEADER

    // Reg - I3CCSR.I3C_EC.TTI.CONTROL
    class I3CCSR__I3C_EC__TTI__CONTROL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__CONTROL_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__TTI__CONTROL_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__TTI__CONTROL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__CONTROL

    // Reg - I3CCSR.I3C_EC.TTI.STATUS
    class I3CCSR__I3C_EC__TTI__STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__STATUS_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__TTI__STATUS_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__TTI__STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__STATUS

    // Reg - I3CCSR.I3C_EC.TTI.INTERRUPT_STATUS
    class I3CCSR__I3C_EC__TTI__INTERRUPT_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__INTERRUPT_STATUS_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__TTI__INTERRUPT_STATUS_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__TTI__INTERRUPT_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__INTERRUPT_STATUS

    // Reg - I3CCSR.I3C_EC.TTI.INTERRUPT_ENABLE
    class I3CCSR__I3C_EC__TTI__INTERRUPT_ENABLE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__INTERRUPT_ENABLE_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__TTI__INTERRUPT_ENABLE_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__TTI__INTERRUPT_ENABLE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__INTERRUPT_ENABLE

    // Reg - I3CCSR.I3C_EC.TTI.INTERRUPT_FORCE
    class I3CCSR__I3C_EC__TTI__INTERRUPT_FORCE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__INTERRUPT_FORCE_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__TTI__INTERRUPT_FORCE_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__TTI__INTERRUPT_FORCE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__INTERRUPT_FORCE

    // Reg - I3CCSR.I3C_EC.TTI.RX_DESC_QUEUE_PORT
    class I3CCSR__I3C_EC__TTI__RX_DESC_QUEUE_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__RX_DESC_QUEUE_PORT_bit_cg [32-1:0]RX_DESC_bit_cg;
        I3CCSR__I3C_EC__TTI__RX_DESC_QUEUE_PORT_fld_cg fld_cg;
        rand uvm_reg_field RX_DESC;

        function new(string name = "I3CCSR__I3C_EC__TTI__RX_DESC_QUEUE_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RX_DESC = new("RX_DESC");
            this.RX_DESC.configure(this, 32, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RX_DESC_bit_cg[bt]) RX_DESC_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__RX_DESC_QUEUE_PORT

    // Reg - I3CCSR.I3C_EC.TTI.RX_DATA_PORT
    class I3CCSR__I3C_EC__TTI__RX_DATA_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__RX_DATA_PORT_bit_cg [32-1:0]RX_DATA_bit_cg;
        I3CCSR__I3C_EC__TTI__RX_DATA_PORT_fld_cg fld_cg;
        rand uvm_reg_field RX_DATA;

        function new(string name = "I3CCSR__I3C_EC__TTI__RX_DATA_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RX_DATA = new("RX_DATA");
            this.RX_DATA.configure(this, 32, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RX_DATA_bit_cg[bt]) RX_DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__RX_DATA_PORT

    // Reg - I3CCSR.I3C_EC.TTI.TX_DESC_QUEUE_PORT
    class I3CCSR__I3C_EC__TTI__TX_DESC_QUEUE_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__TX_DESC_QUEUE_PORT_bit_cg [32-1:0]TX_DESC_bit_cg;
        I3CCSR__I3C_EC__TTI__TX_DESC_QUEUE_PORT_fld_cg fld_cg;
        rand uvm_reg_field TX_DESC;

        function new(string name = "I3CCSR__I3C_EC__TTI__TX_DESC_QUEUE_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_DESC = new("TX_DESC");
            this.TX_DESC.configure(this, 32, 0, "WO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_DESC_bit_cg[bt]) TX_DESC_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__TX_DESC_QUEUE_PORT

    // Reg - I3CCSR.I3C_EC.TTI.TX_DATA_PORT
    class I3CCSR__I3C_EC__TTI__TX_DATA_PORT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__TX_DATA_PORT_bit_cg [32-1:0]TX_DATA_bit_cg;
        I3CCSR__I3C_EC__TTI__TX_DATA_PORT_fld_cg fld_cg;
        rand uvm_reg_field TX_DATA;

        function new(string name = "I3CCSR__I3C_EC__TTI__TX_DATA_PORT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TX_DATA = new("TX_DATA");
            this.TX_DATA.configure(this, 32, 0, "WO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TX_DATA_bit_cg[bt]) TX_DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__TX_DATA_PORT

    // Reg - I3CCSR.I3C_EC.TTI.QUEUE_SIZE
    class I3CCSR__I3C_EC__TTI__QUEUE_SIZE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__QUEUE_SIZE_bit_cg [8-1:0]RX_DESC_BUFFER_SIZE_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_SIZE_bit_cg [8-1:0]TX_DESC_BUFFER_SIZE_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_SIZE_bit_cg [8-1:0]RX_DATA_BUFFER_SIZE_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_SIZE_bit_cg [8-1:0]TX_DATA_BUFFER_SIZE_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_SIZE_fld_cg fld_cg;
        rand uvm_reg_field RX_DESC_BUFFER_SIZE;
        rand uvm_reg_field TX_DESC_BUFFER_SIZE;
        rand uvm_reg_field RX_DATA_BUFFER_SIZE;
        rand uvm_reg_field TX_DATA_BUFFER_SIZE;

        function new(string name = "I3CCSR__I3C_EC__TTI__QUEUE_SIZE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RX_DESC_BUFFER_SIZE = new("RX_DESC_BUFFER_SIZE");
            this.RX_DESC_BUFFER_SIZE.configure(this, 8, 0, "RO", 0, 'h5, 1, 1, 0);
            this.TX_DESC_BUFFER_SIZE = new("TX_DESC_BUFFER_SIZE");
            this.TX_DESC_BUFFER_SIZE.configure(this, 8, 8, "RO", 0, 'h5, 1, 1, 0);
            this.RX_DATA_BUFFER_SIZE = new("RX_DATA_BUFFER_SIZE");
            this.RX_DATA_BUFFER_SIZE.configure(this, 8, 16, "RO", 0, 'h5, 1, 1, 0);
            this.TX_DATA_BUFFER_SIZE = new("TX_DATA_BUFFER_SIZE");
            this.TX_DATA_BUFFER_SIZE.configure(this, 8, 24, "RO", 0, 'h5, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RX_DESC_BUFFER_SIZE_bit_cg[bt]) RX_DESC_BUFFER_SIZE_bit_cg[bt] = new();
                foreach(TX_DESC_BUFFER_SIZE_bit_cg[bt]) TX_DESC_BUFFER_SIZE_bit_cg[bt] = new();
                foreach(RX_DATA_BUFFER_SIZE_bit_cg[bt]) RX_DATA_BUFFER_SIZE_bit_cg[bt] = new();
                foreach(TX_DATA_BUFFER_SIZE_bit_cg[bt]) TX_DATA_BUFFER_SIZE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__QUEUE_SIZE

    // Reg - I3CCSR.I3C_EC.TTI.QUEUE_THRESHOLD_CONTROL
    class I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL_bit_cg [8-1:0]RX_DESC_THLD_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL_bit_cg [8-1:0]TX_DESC_THLD_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL_bit_cg [8-1:0]RX_DATA_THLD_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL_bit_cg [8-1:0]TX_DATA_THLD_bit_cg;
        I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL_fld_cg fld_cg;
        rand uvm_reg_field RX_DESC_THLD;
        rand uvm_reg_field TX_DESC_THLD;
        rand uvm_reg_field RX_DATA_THLD;
        rand uvm_reg_field TX_DATA_THLD;

        function new(string name = "I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RX_DESC_THLD = new("RX_DESC_THLD");
            this.RX_DESC_THLD.configure(this, 8, 0, "RW", 0, 'h0, 1, 1, 0);
            this.TX_DESC_THLD = new("TX_DESC_THLD");
            this.TX_DESC_THLD.configure(this, 8, 8, "RW", 0, 'h0, 1, 1, 0);
            this.RX_DATA_THLD = new("RX_DATA_THLD");
            this.RX_DATA_THLD.configure(this, 8, 16, "RW", 0, 'h0, 1, 1, 0);
            this.TX_DATA_THLD = new("TX_DATA_THLD");
            this.TX_DATA_THLD.configure(this, 8, 24, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RX_DESC_THLD_bit_cg[bt]) RX_DESC_THLD_bit_cg[bt] = new();
                foreach(TX_DESC_THLD_bit_cg[bt]) TX_DESC_THLD_bit_cg[bt] = new();
                foreach(RX_DATA_THLD_bit_cg[bt]) RX_DATA_THLD_bit_cg[bt] = new();
                foreach(TX_DATA_THLD_bit_cg[bt]) TX_DATA_THLD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL

    // Regfile - I3CCSR.I3C_EC.TTI
    class I3CCSR__I3C_EC__TTI extends uvm_reg_block;
        rand I3CCSR__I3C_EC__TTI__EXTCAP_HEADER EXTCAP_HEADER;
        rand I3CCSR__I3C_EC__TTI__CONTROL CONTROL;
        rand I3CCSR__I3C_EC__TTI__STATUS STATUS;
        rand I3CCSR__I3C_EC__TTI__INTERRUPT_STATUS INTERRUPT_STATUS;
        rand I3CCSR__I3C_EC__TTI__INTERRUPT_ENABLE INTERRUPT_ENABLE;
        rand I3CCSR__I3C_EC__TTI__INTERRUPT_FORCE INTERRUPT_FORCE;
        rand I3CCSR__I3C_EC__TTI__RX_DESC_QUEUE_PORT RX_DESC_QUEUE_PORT;
        rand I3CCSR__I3C_EC__TTI__RX_DATA_PORT RX_DATA_PORT;
        rand I3CCSR__I3C_EC__TTI__TX_DESC_QUEUE_PORT TX_DESC_QUEUE_PORT;
        rand I3CCSR__I3C_EC__TTI__TX_DATA_PORT TX_DATA_PORT;
        rand I3CCSR__I3C_EC__TTI__QUEUE_SIZE QUEUE_SIZE;
        rand I3CCSR__I3C_EC__TTI__QUEUE_THRESHOLD_CONTROL QUEUE_THRESHOLD_CONTROL;

        function new(string name = "I3CCSR__I3C_EC__TTI");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.EXTCAP_HEADER = new("EXTCAP_HEADER");
            this.EXTCAP_HEADER.configure(this);

            this.EXTCAP_HEADER.build();
            this.default_map.add_reg(this.EXTCAP_HEADER, 'h0);
            this.CONTROL = new("CONTROL");
            this.CONTROL.configure(this);

            this.CONTROL.build();
            this.default_map.add_reg(this.CONTROL, 'h4);
            this.STATUS = new("STATUS");
            this.STATUS.configure(this);

            this.STATUS.build();
            this.default_map.add_reg(this.STATUS, 'h8);
            this.INTERRUPT_STATUS = new("INTERRUPT_STATUS");
            this.INTERRUPT_STATUS.configure(this);

            this.INTERRUPT_STATUS.build();
            this.default_map.add_reg(this.INTERRUPT_STATUS, 'hc);
            this.INTERRUPT_ENABLE = new("INTERRUPT_ENABLE");
            this.INTERRUPT_ENABLE.configure(this);

            this.INTERRUPT_ENABLE.build();
            this.default_map.add_reg(this.INTERRUPT_ENABLE, 'h10);
            this.INTERRUPT_FORCE = new("INTERRUPT_FORCE");
            this.INTERRUPT_FORCE.configure(this);

            this.INTERRUPT_FORCE.build();
            this.default_map.add_reg(this.INTERRUPT_FORCE, 'h14);
            this.RX_DESC_QUEUE_PORT = new("RX_DESC_QUEUE_PORT");
            this.RX_DESC_QUEUE_PORT.configure(this);

            this.RX_DESC_QUEUE_PORT.build();
            this.default_map.add_reg(this.RX_DESC_QUEUE_PORT, 'h18);
            this.RX_DATA_PORT = new("RX_DATA_PORT");
            this.RX_DATA_PORT.configure(this);

            this.RX_DATA_PORT.build();
            this.default_map.add_reg(this.RX_DATA_PORT, 'h1c);
            this.TX_DESC_QUEUE_PORT = new("TX_DESC_QUEUE_PORT");
            this.TX_DESC_QUEUE_PORT.configure(this);

            this.TX_DESC_QUEUE_PORT.build();
            this.default_map.add_reg(this.TX_DESC_QUEUE_PORT, 'h20);
            this.TX_DATA_PORT = new("TX_DATA_PORT");
            this.TX_DATA_PORT.configure(this);

            this.TX_DATA_PORT.build();
            this.default_map.add_reg(this.TX_DATA_PORT, 'h24);
            this.QUEUE_SIZE = new("QUEUE_SIZE");
            this.QUEUE_SIZE.configure(this);

            this.QUEUE_SIZE.build();
            this.default_map.add_reg(this.QUEUE_SIZE, 'h28);
            this.QUEUE_THRESHOLD_CONTROL = new("QUEUE_THRESHOLD_CONTROL");
            this.QUEUE_THRESHOLD_CONTROL.configure(this);

            this.QUEUE_THRESHOLD_CONTROL.build();
            this.default_map.add_reg(this.QUEUE_THRESHOLD_CONTROL, 'h2c);
        endfunction : build
    endclass : I3CCSR__I3C_EC__TTI

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.EXTCAP_HEADER
    class I3CCSR__I3C_EC__SoCMgmtIf__EXTCAP_HEADER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__EXTCAP_HEADER_bit_cg [8-1:0]CAP_ID_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__EXTCAP_HEADER_bit_cg [16-1:0]CAP_LENGTH_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__EXTCAP_HEADER_fld_cg fld_cg;
        rand uvm_reg_field CAP_ID;
        rand uvm_reg_field CAP_LENGTH;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__EXTCAP_HEADER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CAP_ID = new("CAP_ID");
            this.CAP_ID.configure(this, 8, 0, "RO", 0, 'hc1, 1, 1, 0);
            this.CAP_LENGTH = new("CAP_LENGTH");
            this.CAP_LENGTH.configure(this, 16, 8, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CAP_ID_bit_cg[bt]) CAP_ID_bit_cg[bt] = new();
                foreach(CAP_LENGTH_bit_cg[bt]) CAP_LENGTH_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__EXTCAP_HEADER

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_CONTROL
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_CONTROL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_CONTROL_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_CONTROL_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_CONTROL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_CONTROL

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_STATUS
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_STATUS_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_STATUS_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_STATUS

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_RSVD_0
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_0_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_0_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_0

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_RSVD_1
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_1_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_1_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_1

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_RSVD_2
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_2 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_2_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_2_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_2");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_2

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_RSVD_3
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_3 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_3_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_3_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_3");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_3

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_0
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_0_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_0_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_0

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_1
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_1_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_1_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_1

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_2
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_2 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_2_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_2_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_2");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_2

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_3
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_3 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_3_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_3_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_3");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_3

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_4
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_4 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_4_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_4_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_4");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_4

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_5
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_5 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_5_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_5_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_5");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_5

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_6
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_6 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_6_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_6_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_6");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_6

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_7
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_7 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_7_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_7_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_7");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_7

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_8
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_8 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_8_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_8_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_8");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_8

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_9
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_9 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_9_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_9_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_9");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_9

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_10
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_10 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_10_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_10_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_10");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_10

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_11
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_11 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_11_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_11_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_11");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_11

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_12
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_12 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_12_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_12_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_12");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_12

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_13
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_13 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_13_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_13_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_13");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_13

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_14
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_14 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_14_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_14_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_14");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_14

    // Reg - I3CCSR.I3C_EC.SoCMgmtIf.SOC_MGMT_FEATURE_15
    class I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_15 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_15_bit_cg [32-1:0]PLACEHOLDER_bit_cg;
        I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_15_fld_cg fld_cg;
        rand uvm_reg_field PLACEHOLDER;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_15");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.PLACEHOLDER = new("PLACEHOLDER");
            this.PLACEHOLDER.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(PLACEHOLDER_bit_cg[bt]) PLACEHOLDER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_15

    // Regfile - I3CCSR.I3C_EC.SoCMgmtIf
    class I3CCSR__I3C_EC__SoCMgmtIf extends uvm_reg_block;
        rand I3CCSR__I3C_EC__SoCMgmtIf__EXTCAP_HEADER EXTCAP_HEADER;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_CONTROL SOC_MGMT_CONTROL;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_STATUS SOC_MGMT_STATUS;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_0 SOC_MGMT_RSVD_0;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_1 SOC_MGMT_RSVD_1;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_2 SOC_MGMT_RSVD_2;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_RSVD_3 SOC_MGMT_RSVD_3;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_0 SOC_MGMT_FEATURE_0;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_1 SOC_MGMT_FEATURE_1;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_2 SOC_MGMT_FEATURE_2;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_3 SOC_MGMT_FEATURE_3;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_4 SOC_MGMT_FEATURE_4;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_5 SOC_MGMT_FEATURE_5;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_6 SOC_MGMT_FEATURE_6;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_7 SOC_MGMT_FEATURE_7;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_8 SOC_MGMT_FEATURE_8;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_9 SOC_MGMT_FEATURE_9;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_10 SOC_MGMT_FEATURE_10;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_11 SOC_MGMT_FEATURE_11;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_12 SOC_MGMT_FEATURE_12;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_13 SOC_MGMT_FEATURE_13;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_14 SOC_MGMT_FEATURE_14;
        rand I3CCSR__I3C_EC__SoCMgmtIf__SOC_MGMT_FEATURE_15 SOC_MGMT_FEATURE_15;

        function new(string name = "I3CCSR__I3C_EC__SoCMgmtIf");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.EXTCAP_HEADER = new("EXTCAP_HEADER");
            this.EXTCAP_HEADER.configure(this);

            this.EXTCAP_HEADER.build();
            this.default_map.add_reg(this.EXTCAP_HEADER, 'h0);
            this.SOC_MGMT_CONTROL = new("SOC_MGMT_CONTROL");
            this.SOC_MGMT_CONTROL.configure(this);

            this.SOC_MGMT_CONTROL.build();
            this.default_map.add_reg(this.SOC_MGMT_CONTROL, 'h4);
            this.SOC_MGMT_STATUS = new("SOC_MGMT_STATUS");
            this.SOC_MGMT_STATUS.configure(this);

            this.SOC_MGMT_STATUS.build();
            this.default_map.add_reg(this.SOC_MGMT_STATUS, 'h8);
            this.SOC_MGMT_RSVD_0 = new("SOC_MGMT_RSVD_0");
            this.SOC_MGMT_RSVD_0.configure(this);

            this.SOC_MGMT_RSVD_0.build();
            this.default_map.add_reg(this.SOC_MGMT_RSVD_0, 'hc);
            this.SOC_MGMT_RSVD_1 = new("SOC_MGMT_RSVD_1");
            this.SOC_MGMT_RSVD_1.configure(this);

            this.SOC_MGMT_RSVD_1.build();
            this.default_map.add_reg(this.SOC_MGMT_RSVD_1, 'h10);
            this.SOC_MGMT_RSVD_2 = new("SOC_MGMT_RSVD_2");
            this.SOC_MGMT_RSVD_2.configure(this);

            this.SOC_MGMT_RSVD_2.build();
            this.default_map.add_reg(this.SOC_MGMT_RSVD_2, 'h14);
            this.SOC_MGMT_RSVD_3 = new("SOC_MGMT_RSVD_3");
            this.SOC_MGMT_RSVD_3.configure(this);

            this.SOC_MGMT_RSVD_3.build();
            this.default_map.add_reg(this.SOC_MGMT_RSVD_3, 'h18);
            this.SOC_MGMT_FEATURE_0 = new("SOC_MGMT_FEATURE_0");
            this.SOC_MGMT_FEATURE_0.configure(this);

            this.SOC_MGMT_FEATURE_0.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_0, 'h1c);
            this.SOC_MGMT_FEATURE_1 = new("SOC_MGMT_FEATURE_1");
            this.SOC_MGMT_FEATURE_1.configure(this);

            this.SOC_MGMT_FEATURE_1.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_1, 'h20);
            this.SOC_MGMT_FEATURE_2 = new("SOC_MGMT_FEATURE_2");
            this.SOC_MGMT_FEATURE_2.configure(this);

            this.SOC_MGMT_FEATURE_2.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_2, 'h24);
            this.SOC_MGMT_FEATURE_3 = new("SOC_MGMT_FEATURE_3");
            this.SOC_MGMT_FEATURE_3.configure(this);

            this.SOC_MGMT_FEATURE_3.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_3, 'h28);
            this.SOC_MGMT_FEATURE_4 = new("SOC_MGMT_FEATURE_4");
            this.SOC_MGMT_FEATURE_4.configure(this);

            this.SOC_MGMT_FEATURE_4.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_4, 'h2c);
            this.SOC_MGMT_FEATURE_5 = new("SOC_MGMT_FEATURE_5");
            this.SOC_MGMT_FEATURE_5.configure(this);

            this.SOC_MGMT_FEATURE_5.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_5, 'h30);
            this.SOC_MGMT_FEATURE_6 = new("SOC_MGMT_FEATURE_6");
            this.SOC_MGMT_FEATURE_6.configure(this);

            this.SOC_MGMT_FEATURE_6.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_6, 'h34);
            this.SOC_MGMT_FEATURE_7 = new("SOC_MGMT_FEATURE_7");
            this.SOC_MGMT_FEATURE_7.configure(this);

            this.SOC_MGMT_FEATURE_7.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_7, 'h38);
            this.SOC_MGMT_FEATURE_8 = new("SOC_MGMT_FEATURE_8");
            this.SOC_MGMT_FEATURE_8.configure(this);

            this.SOC_MGMT_FEATURE_8.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_8, 'h3c);
            this.SOC_MGMT_FEATURE_9 = new("SOC_MGMT_FEATURE_9");
            this.SOC_MGMT_FEATURE_9.configure(this);

            this.SOC_MGMT_FEATURE_9.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_9, 'h40);
            this.SOC_MGMT_FEATURE_10 = new("SOC_MGMT_FEATURE_10");
            this.SOC_MGMT_FEATURE_10.configure(this);

            this.SOC_MGMT_FEATURE_10.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_10, 'h44);
            this.SOC_MGMT_FEATURE_11 = new("SOC_MGMT_FEATURE_11");
            this.SOC_MGMT_FEATURE_11.configure(this);

            this.SOC_MGMT_FEATURE_11.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_11, 'h48);
            this.SOC_MGMT_FEATURE_12 = new("SOC_MGMT_FEATURE_12");
            this.SOC_MGMT_FEATURE_12.configure(this);

            this.SOC_MGMT_FEATURE_12.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_12, 'h4c);
            this.SOC_MGMT_FEATURE_13 = new("SOC_MGMT_FEATURE_13");
            this.SOC_MGMT_FEATURE_13.configure(this);

            this.SOC_MGMT_FEATURE_13.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_13, 'h50);
            this.SOC_MGMT_FEATURE_14 = new("SOC_MGMT_FEATURE_14");
            this.SOC_MGMT_FEATURE_14.configure(this);

            this.SOC_MGMT_FEATURE_14.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_14, 'h54);
            this.SOC_MGMT_FEATURE_15 = new("SOC_MGMT_FEATURE_15");
            this.SOC_MGMT_FEATURE_15.configure(this);

            this.SOC_MGMT_FEATURE_15.build();
            this.default_map.add_reg(this.SOC_MGMT_FEATURE_15, 'h58);
        endfunction : build
    endclass : I3CCSR__I3C_EC__SoCMgmtIf

    // Reg - I3CCSR.I3C_EC.CtrlCfg.EXTCAP_HEADER
    class I3CCSR__I3C_EC__CtrlCfg__EXTCAP_HEADER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__CtrlCfg__EXTCAP_HEADER_bit_cg [8-1:0]CAP_ID_bit_cg;
        I3CCSR__I3C_EC__CtrlCfg__EXTCAP_HEADER_bit_cg [16-1:0]CAP_LENGTH_bit_cg;
        I3CCSR__I3C_EC__CtrlCfg__EXTCAP_HEADER_fld_cg fld_cg;
        rand uvm_reg_field CAP_ID;
        rand uvm_reg_field CAP_LENGTH;

        function new(string name = "I3CCSR__I3C_EC__CtrlCfg__EXTCAP_HEADER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CAP_ID = new("CAP_ID");
            this.CAP_ID.configure(this, 8, 0, "RO", 0, 'h2, 1, 1, 0);
            this.CAP_LENGTH = new("CAP_LENGTH");
            this.CAP_LENGTH.configure(this, 16, 8, "RO", 0, 'h2, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CAP_ID_bit_cg[bt]) CAP_ID_bit_cg[bt] = new();
                foreach(CAP_LENGTH_bit_cg[bt]) CAP_LENGTH_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__CtrlCfg__EXTCAP_HEADER

    // Reg - I3CCSR.I3C_EC.CtrlCfg.CONTROLLER_CONFIG
    class I3CCSR__I3C_EC__CtrlCfg__CONTROLLER_CONFIG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        I3CCSR__I3C_EC__CtrlCfg__CONTROLLER_CONFIG_bit_cg [2-1:0]OPERATION_MODE_bit_cg;
        I3CCSR__I3C_EC__CtrlCfg__CONTROLLER_CONFIG_fld_cg fld_cg;
        rand uvm_reg_field OPERATION_MODE;

        function new(string name = "I3CCSR__I3C_EC__CtrlCfg__CONTROLLER_CONFIG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.OPERATION_MODE = new("OPERATION_MODE");
            this.OPERATION_MODE.configure(this, 2, 4, "RO", 1, 'h1, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(OPERATION_MODE_bit_cg[bt]) OPERATION_MODE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : I3CCSR__I3C_EC__CtrlCfg__CONTROLLER_CONFIG

    // Regfile - I3CCSR.I3C_EC.CtrlCfg
    class I3CCSR__I3C_EC__CtrlCfg extends uvm_reg_block;
        rand I3CCSR__I3C_EC__CtrlCfg__EXTCAP_HEADER EXTCAP_HEADER;
        rand I3CCSR__I3C_EC__CtrlCfg__CONTROLLER_CONFIG CONTROLLER_CONFIG;

        function new(string name = "I3CCSR__I3C_EC__CtrlCfg");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.EXTCAP_HEADER = new("EXTCAP_HEADER");
            this.EXTCAP_HEADER.configure(this);

            this.EXTCAP_HEADER.build();
            this.default_map.add_reg(this.EXTCAP_HEADER, 'h0);
            this.CONTROLLER_CONFIG = new("CONTROLLER_CONFIG");
            this.CONTROLLER_CONFIG.configure(this);

            this.CONTROLLER_CONFIG.build();
            this.default_map.add_reg(this.CONTROLLER_CONFIG, 'h4);
        endfunction : build
    endclass : I3CCSR__I3C_EC__CtrlCfg

    // Regfile - I3CCSR.I3C_EC
    class I3CCSR__I3C_EC extends uvm_reg_block;
        rand I3CCSR__I3C_EC__SecFwRecoveryIf SecFwRecoveryIf;
        rand I3CCSR__I3C_EC__StdbyCtrlMode StdbyCtrlMode;
        rand I3CCSR__I3C_EC__TTI TTI;
        rand I3CCSR__I3C_EC__SoCMgmtIf SoCMgmtIf;
        rand I3CCSR__I3C_EC__CtrlCfg CtrlCfg;

        function new(string name = "I3CCSR__I3C_EC");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_NO_ENDIAN);
            this.SecFwRecoveryIf = new("SecFwRecoveryIf");
            this.SecFwRecoveryIf.configure(this);
            this.SecFwRecoveryIf.build();
            this.default_map.add_submap(this.SecFwRecoveryIf.default_map, 'h0);
            this.StdbyCtrlMode = new("StdbyCtrlMode");
            this.StdbyCtrlMode.configure(this);
            this.StdbyCtrlMode.build();
            this.default_map.add_submap(this.StdbyCtrlMode.default_map, 'h80);
            this.TTI = new("TTI");
            this.TTI.configure(this);
            this.TTI.build();
            this.default_map.add_submap(this.TTI.default_map, 'hc0);
            this.SoCMgmtIf = new("SoCMgmtIf");
            this.SoCMgmtIf.configure(this);
            this.SoCMgmtIf.build();
            this.default_map.add_submap(this.SoCMgmtIf.default_map, 'h100);
            this.CtrlCfg = new("CtrlCfg");
            this.CtrlCfg.configure(this);
            this.CtrlCfg.build();
            this.default_map.add_submap(this.CtrlCfg.default_map, 'h160);
        endfunction : build
    endclass : I3CCSR__I3C_EC

    // Reg - I3CCSR.DAT.DAT_MEMORY[]
    class I3CCSR__DAT__DAT_MEMORY extends uvm_vreg;
        rand uvm_vreg_field STATIC_ADDRESS;
        rand uvm_vreg_field IBI_PAYLOAD;
        rand uvm_vreg_field IBI_REJECT;
        rand uvm_vreg_field CRR_REJECT;
        rand uvm_vreg_field TS;
        rand uvm_vreg_field DYNAMIC_ADDRESS;
        rand uvm_vreg_field RING_ID;
        rand uvm_vreg_field DEV_NACK_RETRY_CNT;
        rand uvm_vreg_field DEVICE;
        rand uvm_vreg_field AUTOCMD_MASK;
        rand uvm_vreg_field AUTOCMD_VALUE;
        rand uvm_vreg_field AUTOCMD_MODE;
        rand uvm_vreg_field AUTOCMD_HDR_CODE;

        function new(string name = "I3CCSR__DAT__DAT_MEMORY");
            super.new(name, 64);
        endfunction : new

        virtual function void build();
            this.STATIC_ADDRESS = new("STATIC_ADDRESS");
            this.STATIC_ADDRESS.configure(this, 7, 0);
            this.IBI_PAYLOAD = new("IBI_PAYLOAD");
            this.IBI_PAYLOAD.configure(this, 1, 12);
            this.IBI_REJECT = new("IBI_REJECT");
            this.IBI_REJECT.configure(this, 1, 13);
            this.CRR_REJECT = new("CRR_REJECT");
            this.CRR_REJECT.configure(this, 1, 14);
            this.TS = new("TS");
            this.TS.configure(this, 1, 15);
            this.DYNAMIC_ADDRESS = new("DYNAMIC_ADDRESS");
            this.DYNAMIC_ADDRESS.configure(this, 8, 16);
            this.RING_ID = new("RING_ID");
            this.RING_ID.configure(this, 3, 26);
            this.DEV_NACK_RETRY_CNT = new("DEV_NACK_RETRY_CNT");
            this.DEV_NACK_RETRY_CNT.configure(this, 2, 29);
            this.DEVICE = new("DEVICE");
            this.DEVICE.configure(this, 1, 31);
            this.AUTOCMD_MASK = new("AUTOCMD_MASK");
            this.AUTOCMD_MASK.configure(this, 8, 32);
            this.AUTOCMD_VALUE = new("AUTOCMD_VALUE");
            this.AUTOCMD_VALUE.configure(this, 8, 40);
            this.AUTOCMD_MODE = new("AUTOCMD_MODE");
            this.AUTOCMD_MODE.configure(this, 3, 48);
            this.AUTOCMD_HDR_CODE = new("AUTOCMD_HDR_CODE");
            this.AUTOCMD_HDR_CODE.configure(this, 8, 51);
        endfunction : build
    endclass : I3CCSR__DAT__DAT_MEMORY

    // Mem - I3CCSR.DAT
    class I3CCSR__DAT extends uvm_reg_block;
        rand uvm_mem m_mem;
        rand I3CCSR__DAT__DAT_MEMORY DAT_MEMORY;

        function new(string name = "I3CCSR__DAT");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 8.0, UVM_NO_ENDIAN);
            this.m_mem = new("m_mem", 128, 64, "RW");
            this.m_mem.configure(this);
            this.default_map.add_mem(this.m_mem, 0);
            this.DAT_MEMORY = new("DAT_MEMORY");
            this.DAT_MEMORY.configure(this, this.m_mem, 128);
            this.DAT_MEMORY.build();
        endfunction : build
    endclass : I3CCSR__DAT

    // Reg - I3CCSR.DCT.DCT_MEMORY[]
    class I3CCSR__DCT__DCT_MEMORY extends uvm_vreg;
        rand uvm_vreg_field PID_HI;
        rand uvm_vreg_field PID_LO;
        rand uvm_vreg_field DCR;
        rand uvm_vreg_field BCR;
        rand uvm_vreg_field DYNAMIC_ADDRESS;

        function new(string name = "I3CCSR__DCT__DCT_MEMORY");
            super.new(name, 128);
        endfunction : new

        virtual function void build();
            this.PID_HI = new("PID_HI");
            this.PID_HI.configure(this, 32, 0);
            this.PID_LO = new("PID_LO");
            this.PID_LO.configure(this, 16, 32);
            this.DCR = new("DCR");
            this.DCR.configure(this, 8, 64);
            this.BCR = new("BCR");
            this.BCR.configure(this, 8, 72);
            this.DYNAMIC_ADDRESS = new("DYNAMIC_ADDRESS");
            this.DYNAMIC_ADDRESS.configure(this, 8, 96);
        endfunction : build
    endclass : I3CCSR__DCT__DCT_MEMORY

    // Mem - I3CCSR.DCT
    class I3CCSR__DCT extends uvm_reg_block;
        rand uvm_mem m_mem;
        rand I3CCSR__DCT__DCT_MEMORY DCT_MEMORY;

        function new(string name = "I3CCSR__DCT");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 16.0, UVM_NO_ENDIAN);
            this.m_mem = new("m_mem", 128, 128, "RW");
            this.m_mem.configure(this);
            this.default_map.add_mem(this.m_mem, 0);
            this.DCT_MEMORY = new("DCT_MEMORY");
            this.DCT_MEMORY.configure(this, this.m_mem, 128);
            this.DCT_MEMORY.build();
        endfunction : build
    endclass : I3CCSR__DCT

    // Addrmap - I3CCSR
    class I3CCSR extends uvm_reg_block;
        rand I3CCSR__I3CBase I3CBase;
        rand I3CCSR__PIOControl PIOControl;
        rand I3CCSR__I3C_EC I3C_EC;
        rand I3CCSR__DAT DAT;
        rand I3CCSR__DCT DCT;

        function new(string name = "I3CCSR");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 16, UVM_NO_ENDIAN);
            this.I3CBase = new("I3CBase");
            this.I3CBase.configure(this);
            this.I3CBase.build();
            this.default_map.add_submap(this.I3CBase.default_map, 'h0);
            this.PIOControl = new("PIOControl");
            this.PIOControl.configure(this);
            this.PIOControl.build();
            this.default_map.add_submap(this.PIOControl.default_map, 'h80);
            this.I3C_EC = new("I3C_EC");
            this.I3C_EC.configure(this);
            this.I3C_EC.build();
            this.default_map.add_submap(this.I3C_EC.default_map, 'h100);
            this.DAT = new("DAT");
            this.DAT.configure(this);
            this.DAT.build();
            this.default_map.add_submap(this.DAT.default_map, 'h400);
            this.DCT = new("DCT");
            this.DCT.configure(this);
            this.DCT.build();
            this.default_map.add_submap(this.DCT.default_map, 'h800);
        endfunction : build
    endclass : I3CCSR

    `include "I3CCSR_sample.svh"
endpackage: registers_uvm
